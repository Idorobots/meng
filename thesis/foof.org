# ###############################################################################
#+TITLE:
#+AUTHOR: Kajetan Rzepecki
#+DATE: 2015
#+LANGUAGE: pl
#
#+STARTUP: content
#+EXPORT_SELECT_TAGS: export
#+LaTeX_CLASS: aghdpl
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt]
#+LaTeX_HEADER: \usepackage[polish]{babel}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{multicol}
#+LATEX_HEADER: \usepackage[nottoc, notlof, notlot]{tocbibind}
#+OPTIONS: tags:nil, todo:nil, toc:nil
# ###################

# Helpers & Stuff
#+begin_src emacs-lisp :exports none
  (setq org-latex-minted-options
        '(("frame" "leftline") ("linenos" "true") ("mathescape" "true")))

  (setq org-export-latex-title-command "")
  (add-to-list 'org-latex-classes
               '("aghdpl"
                 "\\documentclass{aghdpl}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))

  (setq org-latex-classes (cdr org-latex-classes))
#+end_src

# AGH setup:
#+LATEX_HEADER: \shortauthor{K. Rzepecki}
#+LATEX_HEADER: \degreeprogramme{Informatyka}

#+LATEX_HEADER: \thesistype{Praca dyplomowa magisterska}

#+LATEX_HEADER: \titlePL{Projekt języka programowania wspierającego przetwarzanie rozproszone na platformach heterogenicznych.}
#+LATEX_HEADER: \titleEN{Design of a programming language with support for distributed computing on heterogenous platforms.}

#+LATEX_HEADER: \shorttitlePL{Projekt języka programowania wspierającego przetwarzanie rozproszone \dots}
#+LATEX_HEADER: \shorttitleEN{Design of a programming language with support for distributed computing \dots}

#+LATEX_HEADER: \supervisor{dr inż. Piotr Matyasik}

#+LATEX_HEADER: \department{Katedra Informatyki Stosowanej}

#+LATEX_HEADER: \faculty{Wydział Elektrotechniki, Automatyki,\protect\\[-1mm] Informatyki i Inżynierii Biomedycznej}

#+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję opiekunowi pracy za wsparcie merytoryczne oraz dobre rady edytorskie pomocne w tworzeniu pracy.}
# #+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję Lucynie oraz siostrze Alicji za cierpliwość i wsparcie podczas tworzenia pracy dyplomowej.}

# Font stuff:
#+LATEX_HEADER: \setmainfont{Times New Roman}
#+LATEX_HEADER: \setmonofont{Consolas}

# Title pages & table of contents:
#+begin_latex
\titlepages
\tableofcontents
#+end_latex

# List of Listings specific:
#+begin_latex
\newcommand{\listlistingname}{\bfseries\Large{Spis listingów}}
\newlistof[chapter]{mylisting}{mlol}{\listlistingname}
\newcommand{\mylisting}[1]{%
  \refstepcounter{mylisting}%
  #1%
  \addcontentsline{mlol}{figure}
    {\protect\numberline{\thechapter.\thelisting}#1}\par%
}
\renewcommand{\cftbeforemloltitleskip}{20mm}
\renewcommand{\cftaftermloltitleskip}{5mm}
#+end_latex

* Wstęp
#+latex: \label{sec:intro}

Tematem pracy jest projekt i implementacja języka programowania wspierającego /przetwarzanie współbieżne/ i umożliwiającego tworzenie /systemów rozproszonych/ działających na /platformach heterogenicznych/.

Przetwarzanie współbieżne polega na podziale obliczeń na wiele procesów działających jednocześnie i konkurujących ze sobą o dostęp do ograniczonej ilości zasobów [[cite:McKenney2015]]. Procesy te mogą zostać rozproszone na wiele fizycznych maszyn, zachowując jednocześnie komunikację pomiędzy nimi, tworząc tym samym jeden koherentny system rozproszony [[cite:Tanenbaum2006]].

Projektowany język programowania powinien więc udostępniać przejrzystą i ogólną notację umożliwiającą definiowanie komunikujących się procesów, jednocześnie pozostając językiem ogólnego przeznaczenia. Dodatkowym wymogiem jest prostota przy zachowaniu ekspresywności - język ten powinien być zbudowany w oparciu o niewielką liczbę ortogonalnych, dobrze współgrających ze sobą mechanizmów, które pozwalają na implementację szerokiej gamy funkcjonalności [[cite:Backus1978]].

#+begin_center
#+label: fig:lang-parts
#+caption: Schemat interakcji poszczególnych elementów języka.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/langparts.pdf]]
#+end_center

W tym celu wymagane jest stworzenie kompilatora, czyli programu transformującego kod źródłowy języka programowania na format możliwy do uruchomienia w pewnym środowisku uruchomieniowym (ang. /runtime system/). Na środowisko takie zazwyczaj składa się zestaw podstawowych procedur wspólnych i niezbędnych do działania każdego programu. Schemat interakcji poszczególnych elementów projektu zaprezentowano na schemacie [[fig:lang-parts]].

Ostatnim wymogiem postawionym przed projektowanym językiem, jest wyjście naprzeciw licznym problemom występującym w systemach rozproszonych, w szczególności problemowi /heterogeniczności/, co umotywowano w następnej sekcji.

** Motywacja pracy
Tworzenie systemów rozproszonych jest zadaniem bardzo trudnym i wymaga wykorzystania specjalnie do tego przeznaczonych narzędzi - języków programowania, systemów bazodanowych i infrastruktury sieciowej. Na przestrzeni lat zidentyfikowano wiele kluczowych problemów manifestujących się we wszystkich systemach rozproszonych niezależnie od ich przeznaczenia. Tanenbaum oraz Van Steen w [[cite:Tanenbaum2006]] wymieniają następujące problemy:

- *dostępność* - systemy rozproszone działają zwykle na wielu odrębnych maszynach, istotnym jest więc zachowanie dostępu do wspólnych zasobów z każdej części systemu,

- *przezroczystość dystrybucji* - istotnym jest również ukrycie fizycznego rozproszenia procesów i zasobów, dzięki czemu system rozproszony z zewnątrz stanowi jedną, koherentną całość,

- *otwartość* - polega na standaryzacji komunikacji pomiędzy poszczególnymi częściami systemu, dzięki czemu możliwe jest dodawanie nowych elementów bez ingerencji w pozostałe,

- *skalowalność* - systemy rozproszone powinny umożliwiać płynną zmianę ilości zasobów, być dostępne dla użytkowników z wielu lokacji geograficznych oraz umożliwiać łatwe zarządzanie niezależnie od ich rozmiaru.

Warto zauważyć, iż /skalowalność/ jest przywoływana w folklorze programistycznym nieproporcjonalnie często, natomiast, istnieje wiele równie trudnych problemów, którym przeznacza się znacznie mniej uwagi, takich jak:

- *bezpieczeństwo systemu* - polega na kontroli dostępu do zasobów; w zależności od przeznaczenia systemu rozproszonego, jest najważniejszym aspektem jego budowy,

- *odporność na błędy* - polega na reagowaniu na zmiany (w szczególności wystąpienie błędów) zachodzące w systemie i podejmowaniu odpowiednich akcji w razie ich wystąpienia,

- *heterogeniczność* - polega na zróżnicowaniu platform sprzętowych wchodzących w skład fizycznej części systemu rozproszonego, a także poszczególnych logicznych części systemu.

Heterogeniczność jest problemem szczególnie trudnym, który powoli nabiera znaczenia wraz z pojawieniem się inicjatyw takich jak *Internet Rzeczy* (ang. /Internet of Things/) [[cite:Holler2014]], gdzie systemy rozproszone zbudowane są z dużej ilości bardzo zróżnicowanych maszyn. Maszyny te cechują się różną architekturą sprzętową, ilością zasobów, a także przeznaczeniem i funkcjonalnościami, które realizują i umożliwiają.

Na schemacie [[fig:hetero-iot]] przedstawiony został przykład heterogeniczności platformy sprzętowej w kontekście Internetu Rzeczy. Klient, korzystając z centralnego komputera, uzyskuje dostęp do danych sensorycznych pochodzących z szerokiej gamy różnych czujników i bazując na ich wartości jest w stanie zmieniać zachowanie równie zróżnicowanych efektorów. Całość odbywa się za pośrednictwem dedykowanych sterowników, ułatwiających skalowanie systemu.

#+begin_center
#+label: fig:hetero-iot
#+caption: Przykład systemu opartego o heterogeniczną platformę sprzętową.
#+attr_latex: :width 0.7\textwidth :placement [H]
[[file:./img/heteroiotexample.pdf]]
#+end_center

Każdy element takiego systemu, oznaczony na schemacie różnym kształtem oraz kolorem, reprezentuje maszynę udostępniającą różne zasoby i posiadającą różną fizyczną konstrukcję. Poszczególne elementy często działają w niekompatybilny sposób, w związku z czym wymagane jest wykorzystanie dedykowanych pośredników, których jedynym zadaniem jest /homogenizacja/ systemu.

Problem heterogeniczności dotyka również systemów rozproszonych, które działają na platformach homogenicznych, gdzie fizyczne maszyny są do siebie bardzo zbliżone, a często są komputerami ogólnego przeznaczenia. Przykład takiego systemu, zbudowanego w oparciu o zdobywającą popularność architekturę mikroserwisową [[cite:Richards2015]], został zawarty na schemacie [[fig:hetero-service]].

Użytkownik systemu łączy się z głównym serwisem, który następnie komunikuje się z innymi serwisami, realizującymi wymagane przezeń zadania. W celu poprawienia /odporności na błędy/ takiego systemu, w strategicznych miejscach umieszczono serwery zarządzające ruchem (ang. /load-balancer/), których zadaniem, analogicznie do przykładu ze schematu [[fig:hetero-iot]], jest /homogenizacja/ systemu.

#+begin_center
#+label: fig:hetero-service
#+caption: Przykład systemu heterogenicznego niezależnie od platformy sprzętowej.
#+attr_latex: :width 0.7\textwidth :placement [H]
[[file:./img/heteroserviceexample.pdf]]
#+end_center

W pierszym przypadku heterogeniczność wynika ze zróżnicowania maszyn należących do platformy sprzętowej, natomiast w drugim wynika ona z istnienia mikroserwisów, które realizują pojedyncze, konretnie sprecyzowane funkcjonalności. W obu przypadkach, heterogeniczność systemu prowadzi do powstania innych problemów, takich jak skalowalność i odporność na błędy, oraz konieczności wykorzystania dodatkowych elementów mających im zaradzić.

Często, sytuacja ta wynika z nieadekwatności narzędzi (w szczególności języków programowania) wykorzystanych do tworzenia systemu. Popularne języki programowania dążą do osiągnięcia *niezalożności od platformy* (ang. /platform independence/) stosując maszyny wirtualne i inne techniki mające na celu homogenizację platformy sprzętowej, kiedy w rzeczywistości osiągają *ignorancję platformy* nie umożliwiając refleksji na jej temat.

Jako alternatywę dla osiągnięcia niezależności od platformy, niniejsza praca wprowadza termin *świadomości platformy* (ang. /platform awareness/), czyli dążenia do udostępnienia wiedzy o strukturze budowanego systemu rozproszonego oraz platformy sprzętowej, na której działa, i umożliwienia refleksji na jej podstawie. Zaprezentowany w dalszej części pracy język programowania, roboczo zwany =FOOF= [fn:: Nazwa pochodzi od difluorku ditlenu, niezwykle reaktywnego, dysruptywnego i niebezpiecznego związku chemicznego, który nie ma zastosowania.], ma być uosobieniem ideologii świadomości platformy.

** Zawartość pracy
- list what is found where in the thesis

* Język =FOOF=
Niniejszy rozdział szczegółowo opisuje projekt języka programowania =FOOF= począwszy od podstawowych typów danych, przez notację funkcji, kontynuacji i procesów, kończąc na zaawansowanych mechanizmach języka, takich jak przetwarzanie wiedzy i wbudowany system makr. W dodatku [[ref:sec:foof-grammar]] zawarto formalny opis gramatyki języka, natomiast w dodatku [[ref:sec:foof-examples]] zamieszczono kilka przykładowych programów.

Język =FOOF= został zaprojektowany bazując na cennych wskazówkach przedstawionych przez John'a Backus'a w wykładzie wygłoszonym przez niego podczas odbierania Nagrody Turing'a w 1977 roku [[cite:Backus1978]]. Wskazówki te są ponadczasowe i stanowią dobrą podstawę do tworzenia języków programowania, a w dużym skrócie sprowadzają się do następujących punktów:

- *prostota lecz nie surowość* (ang. /simplicity, not crudeness/) - języki programowania powinny cechować się prostotą, lecz nie ograniczać ekspresywności programisty przez brak możliwości zrealizowania pewnych funkcjonalności, a co za tym idzie:

- *ortogonalne funkcjonalności* (ang. /orthogonal features/) - język programowania powinien składać się z niewielkiej liczby dobrze zdefiniowanych i dobrze współgrających mechanizmów, za pomocą których programista jest w stanie łatwo zbudować wszelkie inne potrzebne funkcjonalności.

Oczywiście, zasady te nie są wystarczające do stworzenia funkcjonalnego języka programowania, dlatego kierowano się także *pragmatyzmem*, który w kontekście projektowania języków programowania sprowadza się do podejmowania kompromisów, pomiędzy /matematyczną czystością/ a faktyczną użytecznością potencjalnych funkcjonalności dostarczanych przez język. Podejście to zostało szczegółowo opisane w [[cite:Hoare1973]].

Ze względu na podobne zasady, którymi kierowano się podczas projektowania, język =FOOF= przypomina pod względem składniowym i semantycznym odpowiednio języki *Scheme* (opisany szczegółowo w [[cite:Sperber2010]]) oraz *Standard ML* [[cite:Milner1997]]. Natomiast, cechami odróżniającymi =FOOF= od tych języków są: wsparcie dla programowania współbieżnego oraz wykorzystanie inżynierii wiedzy w celu osiągnięcia /świadomości platformy/ i rozwiązania problemu heterogeniczności systemów rozproszonych.

** Podstawowe typy danych
Listing [[ref:code:basic-data-types]] prezentuje proste typy danych dostępne w języku =FOOF=; są to podstawowe elementy budulcowe programów, które mają swoją reprezentację literałową.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Podstawowe typy danych dostępne w języku \texttt{FOOF}.}}
#+latex: \label{code:basic-data-types}
#+begin_src clojure
23.5
symbol
:symbol
"ciąg znaków"
(1 2 3)
[1 2 3]
{:a 1 :b 2}
#+end_src
#+latex: \end{listing}

Typy te to w kolejności: liczby, symbole, słowa kluczowe i ciągi znaków tekstowych, stanowiące wspólnie klasę wartości atomowych oraz listy pojedynczo-wiązane, wektory i mapy asocjacyjne. Każdy nieatomowy typ danych składa się z określonej liczby podwartości, które mogą być atomowe, lub nieatomowe. Semantyka każdego wymienionego typu danych jest zgodna z analogicznymi konstrukcjami opisanymi w [[cite:Sperber2010]].

Jako, że język =FOOF= jest dialektem języka Lisp, programy kodowane są homoikonicznie przez opisane powyżej typy danych - stosowana jest notacja *S-wyrażeń*, która została wprowadzona w [[cite:McCarthy1960]]. Notacja ta rozmywa granicę pomiędzy programami a danymi, pozwalając programom na manipulację, budowę i transformację innych programów.

Homoikoniczność i notację S-wyrażeń wykorzystano w wielu innych mechanizmach dostępnych w języku, które zostały opisane w dalszej części niniejszego rozdziału, w szczególności w implementacji systemu makr pozwalającego na rozszerzenie składni języka.

** Funkcje
Pierwszym złożonym typem danych, który nie ma reprezentacji literałowej w języku =FOOF= są funkcje. Funkcje są obiektami pierwszej klasy, to znaczy, po stworzeniu podczas działania programu, mogą być wykorzystywane tak jak każdy inny typ danych, a co za tym idzie, mogą być osadzane w listach, przekazywane do innych funkcji, a także z nich zwracane jako wynik obliczeń.

Funkcje zostały zaprojektowane w oparciu o *Rachunek Lambda*, wprowadzony w 1933 roku przez Alonzo Church'a jako alternatywny model logiki i, następnie, prowadzenia obliczeń [[cite:Church1932, Church1933]]. Rachunek ten wprowadza pojęcie *wyrażenia lambda*, które jest ekwiwalentem jednoargumentowych funkcji obecnych języków programowania, oraz szereg zasad substytucji, zwanych redukcjami, pozwalających na uproszczenie zagnieżdżonych wyrażeń lambda. Najważniejszą z wprowadzanych redukcji jest *\beta-redukcja*, która konceptualnie reprezentuje aplikację funkcji z odpowiednimi argumentami i jednocześnie pozwala na prowadzenie obliczeń.

Zasady Rachunku Lambda są fundamentalnie bardzo nieskomplikowane, a mimo to pozwalają na ekspresję skomplikowanych idei, takich jak logika Bool'a, arytmetyka, struktury danych oraz rekurencja. Na listingu [[ref:code:ex-lambda-calculus]] zawarto przykład realizacji logiki boola wraz z kilkoma operatorami logicznymi w czystym Rachunku Lambda.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład implementacji wartości i operatorów logicznych jedynie za pomocą wyrażeń lambda.}}
#+latex: \label{code:ex-lambda-calculus}
#+BEGIN_SRC text
TRUE := λx.λy.x
FALSE := λx.λy.y

AND := λp.λq.p q p
OR := λp.λq.p p q
NOT := λp.λa.λb.p b a

AND TRUE FALSE
    ≡ (λp.λq.p q p) TRUE FALSE →β TRUE FALSE TRUE
    ≡ (λx.λy.x) FALSE TRUE →β FALSE
#+END_SRC
#+latex: \end{listing}

Wartości logiczne kodowane są jako wyrażenia lambda konsumujące dwa argumenty i wybierające odpowiednio pierwszy z nich, dla logicznej wartości prawdy, lub drugi z nich, dla logicznej wartości fałszu. W podobny sposób kodowane są operatory logiczne, a wynik ich działania obliczany jest przez sukcesywne przeprowadzanie substytucji nazwy argumentu na jego wartość oraz redukowaniu otrzymanych wyrażeń za pomocą \beta-redukcji.

Warto zauważyć, że wyrażenia lambda można interpretować jako tak zwane *domknięcia leksykalne*, czyli tworzone podczas \beta-redukcji otaczającego wyrażenia pary funkcji i map asocjacyjnych odzwierciedlających wartości zmiennych, które występują w ciele domknięcia leksykalnego, a nie są przez nie wprowadzane. Domknięcia leksykalne pozwalają opóźnić substytucję nazw argumentów wyrażeń lambda na odpowiadające im wartości, dzięki czemu są łatwiejsze w implementacji [[cite:PeytonJones1992]].

Listing [[ref:code:closures-at-work]] pokazuje działanie domknięć leksykalnych w notacji języka =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ilustrujący działanie domknięć leksykalnych.}}
#+latex: \label{code:closures-at-work}
#+begin_src scheme
(let* ((x 23)
       (foo (lambda () x)))
  (let ((x 5))
    (display (foo)))) ;; Wyświetla liczbę 23
#+end_src
#+latex: \end{listing}

Funkcja =foo= zaprezentowana na listingu, korzysta z wartości *wolnej zmiennej* =x=, czyli takiej, której nie wprowadza w liście swoich argumentów. W dalszej części programu, funkcja =foo=, pomimo lokalnej zmiany wartości zmiennej =x=, poprawnie zwraca oryginalną jej wartość, ponieważ w momencie jej tworzenia wartość zmiennej =x= została zapisana razem z ciałem funkcji.

Często pojawiającym się problemem związanym z funkcjami wzorowanymi na Rachunku Lambda, jest tak zwany problem *funarg*, polegający na niepoprawnym działaniu programów, które zwracają funkcje jako wynik obliczeń, lub przekazują je jako argumenty innych funcji. Problem ten sprowadza się do niewłaściwego budowania domknięć leksykalnych, co może doprowadzić do przedwczesnego usunięcia wartości zmiennych wolnych. Został on poruszony w [[cite:Abelson1996]].

Kolejnym problemem towarzyszącym funkcjom zrealizowanym jako domknięcia leksykalne jest nietrywialna implementacja rekurencji, wynikająca z ustalonej kolejności wykonywania działań - tworzenie domknięcia leksykalnego funkcji rekurencyjnej jest uzależnione od jej uprzedniego istnienia, co prowadzi do sprzeczności.

Oryginalna praca wprowadzająca Rachunek Lambda w celu osiągnięcia rekurencji wykorzystuje rachunek kombinatorów [[cite:Church1932]], a w szczególności *kombinator Y*. Sposób działania tego kombinatora został szczegółowo opisany w [[cite:Felleisen1991]], natomiast problem i propozycję implementacji rekurencji szerzej opisano w [[cite:Rzepecki2015]].

** Kontynuacje
Kolejnym mechanizmem będącym integralną częścią języka =FOOF= są kontynuacje, czyli abstrakcyjne reprezentacje przepływu sterowania programów, które pozwalają jednoznacznie określić kolejność wykonywania obliczeń.

Kontynuacje można interpretować jako ciąg obliczeń pozostałych do wykonania z punktu widzenia danego miejsca programu, który został *reifikowany* jako funkcja i udostępniony z poziomu wykonywanego programu. W efekcie, programy mogą zadecydować by zrestartować obliczenia od pewnego momentu, albo wręcz przeciwnie, przerwać je odrzucając wartości pośrednie.

Jako, że jest to mechanizm skomplikowany, który był odkrywany wielokrotnie [[cite:Reynolds1993]], często nieświadomie, istnieje wiele jego wersji i sposobów implementacji, a w związu z czym nie jest on powszechnie dostępny jako standardowa funkcjonalność popularnych języków programowania. Ze względu na swoje właściwości opisane powyżej, kontynuacje są częściej stosowane w implementacjach kompilatorów języków programowania, jako format pośredni reprezentacji programów [[cite:Appel1992]].

Języki programowania, które korzystają z kontynuacji czasem udostępniają je jako obiekty pierwszej klasy, które mogą być traktowane w taki sam sposób jak inne typy danych. Służy do tego wiele zróżnicowanych operacji prymitywnych, które różnią się semantyką. W przypadku języka Scheme operacja prymitywna służąca do przechwytywania kontynuacji to =call-with-current-continuation= (=call/cc=) [[cite:Sperber2010]], natomiast w języku Standard ML służy ku temu konstrukcja =letcc= [[cite:Harper1998]].

Istnieją także sposoby komponowania kontynuacji, bazujące na tak zwanych kontynuacjach ograniczonych (ang. /delimited continuations/), które wykorzystują większą liczbę operacji prymitywnych, na przykład =shitf= oraz =reset= opisane w [[cite:Dybvig2005]], w celu zapewnienia większej kontroli nad przepływem sterowania programu. Listing [[ref:code:ex-early-return]] demonstruje sposób wykorzystania kontynuacji w języku =FOOF= w celu implementacji wczesnego powrotu z funkcji.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania kontynuacji w języku \texttt{FOOF}.}}
#+latex: \label{code:ex-early-return}
#+begin_src scheme
(lambda (x)
  (letcc return
    ...
    (return 23)
    ...))
#+end_src
#+latex: \end{listing}

Dzięki możliwości przechwycenia kontynuacji, program jest w stanie przedwcześnie zakończyć działanie funkcji z obliczoną wartością. Kontynuacje dostępne są bezpośrednio, dzięki konstrtukcjom =letcc=, =shift= oraz =reset=, a także pośrednio, dzięki gamie innych mechanizmów kontroli przepływu sterowania, takich jak obsługa błędów, czy multiprocessing.

** Obsługa błędów
Jednym z najważniejszych mechanizmów, jakie powinien udostępniać język programowania, jest mechanizm obsługi błędów i sytuacji wyjątkowych.

Język =FOOF= zapewnia mechanizm obsługi błędów, który bazuje na kontynuacjach, w związku z czym charakteryzuje się bardzo dużą ekspresywnością. Mechanizm ten umożliwia, analogicznie do większości popularnych języków programowania, zadeklarowanie procedury obsługi zdarzeń wyjątkowych za pomocą konstukcji =handle= oraz sygnalizację zajścia takiego zdarzenia poprzez =raise=.

W przeciwieństwie do większości języków programowania, mechanizm dostępny w języku =FOOF= pozwala na kontynuowanie obliczeń w miejscu wystąpienia błędu z nową wartością, obliczoną w zadeklarowanej procedurze obsługi błędu. Przykład ilustrujący taki schemat został zaprezentowany na listingu [[ref:code:ex-restarts]].

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania mechanizmu obsługi błędów.}}
#+latex: \label{code:ex-restarts}
#+begin_src scheme
(handle (do ...
            (raise 'error) ;; Błąd w trakcie wykonywania obliczeń.
            ...)
        (lambda (error restart)
          ...
          (restart new-value))) ;; Kontynuacja z nową wartością.
#+end_src
#+latex: \end{listing}

Przykładowy program deklaruje procedurę obsługi sytuacji wyjątkowej, a następnie przechodzi do kosztownych obliczeń, które przedwcześnie sygnalizują wystąpienie błędu. Przepływ sterowania zostaje przekazany do zadeklarowanej procedury obsługi sytuacji wyjątkowej, która decyduje się zrestartować obliczenia dostarczając im nową, poprawną wartość. Następnie, program wraca do punktu wystąpienia błędu i kontynuuje obliczenia wykorzystują nową, poprawną wartość.

** Przetwarzanie współbieżne i rozproszone
Jednym z głównych założeń języka jest wsparcie dla przetwarzania współbieżnego i rozproszonego, dlatego istotnym jest, by abstrakcja to umożliwiająca była prosta, ekspresywna i wygodna w użyciu, ponieważ będzie stanowiła kluczowy element każdego programu, który powstanie w języku =FOOF=. Abstrakcją, która spełnia wszystkie te wymogi jest *Model Aktorowy* zaproponowany przez Carl'a Hewitt'a w 1973 roku [[cite:Hewitt1973]] i rozszerzony o formalny opis semantyki przez Williama Clingera w roku 1981 [[cite:Clinger1981]].

Model Aktorowy bazuje na kilku prostych koncepcjach, takich jak podział programu na wiele działających wspłóbieżnie procesów (aktorów), porozumiewających się poprzez przesyłanie wiadomości, na których podstawie mogą podejmować lokalne decyzje, tworzyć kolejne procesy, lub wysyłać kolejne wiadomości. Listing [[ref:code:ex-actor-model-usage]] prezentuje wszystkie operacje prymitywne udostępniane przez Model Aktorowy.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania prymitywnych operacji Modelu Aktorowego w języku.}}
#+latex: \label{code:ex-actor-model-usage}
#+begin_src scheme
(send (spawn (lambda ()
               (sleep 1000)
               (send (recv) 'message)))
      (self))

(equal? (recv) 'message)
#+end_src
#+latex: \end{listing}

Program ten tworzy nowy proces korzystając z funkcji =spawn=, któremu natychmiastowo wysyła wiadomość za pośrednictwem funkcji =send=, zawierając w niej swój identyfikator =self=, po czym przechodzi do oczekiwania na odpowiedź wywołując funkcję =recv=. Tymczasem, nowopowstały proces zostaje uśpiony na 1000 milisekund (=sleep=) po czym odbiera przesłaną do niego wiadomość i odpowiada na nią wysyłając symbol =message=.

Interfejs ten jest bardzo zbliżony do interfejsu Modelu Aktorowego dostępnego w języku Erlang [[cite:Armstrong1996]] i zaiste był na nim wzorowany. W odróżnieniu od języka Erlang, odbieranie wiadomości nie wykorzystuje dopasowywania wzorców bezpośrednio w prymitywnej operacji =recv=, lecz umożliwia jego osobną implementację. Podobnie, jak w przypadku języka Erlang, projekt przewiduje rozszerzenie listy prymitywnych operacji o identyfikację maszyn, na których działają procesy.

Implementacja Modelu Aktorowego w języku =FOOF= podobnie jak mechanizm obsługi błędów, została oparta o kontynuacje i zostanie opisana szczegółowo w następnych rozdziałach.

** Makra
Prawdobodobnie najciekawszą funkcjonalnością języków z rodziny Lisp jest ich podejście do metaprogramowania i generowania kodu. Większość języków z tej rodziny wykorzystuje wersję systemu *makr*, który pozwala rozszerzać składnię języka i tworzyć dialekty domenowe (ang. /domain specific language/) w prosty i przystępny sposób. Język =FOOF= nie jest wyjątkiem i również został wyposażony w system makr.

Listing [[ref:code:ex-macroexpansion]] prezentuje efekt działania *makroekspansji*, czyli substytucji wywołań makr na definicje ich ciał, na przykładzie kilku wbudowanych makr rozszerzających składnię języka =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład działania systemu makr w języku \texttt{FOOF}.}}
#+latex: \label{code:ex-macroexpansion}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Przed makroekspansją:
(and 23 42)



(let ((x 23))
  (display x))


`(4 is ,(* 2 2))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Po makroekspansji:
(if 23
    42
    false)

((lambda (x)
   (display x))
 23)

(list '4 'is (* 2 2))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Efektem makroekspansji jest powstanie semantycznie ekwiwalentnego kodu, który wykorzystuje tylko dobrze zdefiniowane konstrukcje składniowe języka. Warto zwrócić uwagę na ostatni z przykładów, który prezentuje znaną z innych dialektów języka Lisp konstrukcję =quasiquote=. Konstrukcja ta umożliwia budowanie programów w łatwy, wizualny sposób bez konieczności samodzielnego budowania drzew programu z wykorzystaniem funkcji =cons=, =list= i pokrewnych. Szczegółowy opis działania =quasiquote= został zawarty w [[cite:Bawden1999]].

Systemy makr czesto borykają się z problemami *higieniczności* generowanego kodu. Problem ten ilustruje przykład z listingu [[ref:code:macro-hygiene]].

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ilustrujący problem higieniczności systemu makr w języku Scheme.}}
#+latex: \label{code:macro-hygiene}
#+begin_src scheme
(define-macro (unless c . b)
  `(if (not ,c)
       (begin ,@b)
       #void))

(let ((not identity))
  (unless #t
    (display "Hello world!")))
#+end_src
#+latex: \end{listing}

Zdefiniowane zostaje makro =unless=, którego zadaniem jest uruchamianie pewnych obliczeń jedynie, gdy podany warunek nie jest spełniony. W tym celu makro korzysta z konstrukcji =if= oraz funkcji =not=, nie zachowując, niestety, higieniczności, czego dowodzi druga część przykładu - lokalna zmiana wartości zmiennej =not= na funkcję tożsamości powoduje niewłaściwe działanie makra =unless=.

Problem higieniczności jest problemem skomplikowanym i zazwyczaj jego rozwiązanie oznacza poświęcenie części funkcjonalności systemu makr, na przykład poprzez ograniczenie go do translacji szablonów [[cite:Sperber2010]], lub znacznego jego skomplikowania, przez konieczność wprowadzenia hierarchicznej refleksji makroekspansji [[cite:Queinnec1996]]. Niestety, system makr języka =FOOF= pozostawia ten problem otwartym.

Alternatywnym podejściem do problemu metaprogramowania, o którym warto wspomnieć są *f-wyrażenia* (ang. /f-expressions/, /fexprs/), polegające na podziale funkcji na dwa fundamentalne kompotenty - aplikatywny, indukujący ewaluację argumentów oraz operatywny, analogiczny do substytucji nazw argumentów na ich wartości w wyrażeniach lambda Rachunku Lambda [[cite:Shutt2010]]. Podejście to drastycznie komplikuje kompilację kodu źródłowego, w związku z czym nie zostało wykorzystane w języku =FOOF=.

** System modułowy
W celu umożliwienia podziału kodu źródłowego programów na logicznie związane części i ułatwienia zarządzania nimi, nowoczesne języki programowania często udostępniają systemy modułowe, wraz z niezbędnymi do ich działania rozszerzeniami składniowymi.

Systemy takie, w zależności od języka programowania, na potrzeby którego zostały zaprojektowane, różnią się sposobem działania oraz ekspresywnością. Mniej skomplikowane systemy modułowe polegają na zwyczajnych podstawieniach tekstowych z opcjonalnym wsparciem dla /przestrzeni nazw/ w celu uniknięcia konfliktów identyfikatorów, natomiast bardziej skomplikowane umożliwiają kontrolę dostępu oraz definiowanie zależności pomiędzy poszczególnymi modułami.

System modułowy wykorzystywany w języku =FOOF= jest zbliżony w swojej funkcjonalności do analogicznego systemu języka Standard ML [[cite:Harper1998]], a właściwe jego modyfikacji opisanej w [[cite:Rossberg2015]], gdzie mamy do czynienia ze *strukturami* wiążącymi ze sobą definicje funkcji i zmiennych, oraz *funktorami*, które pozwalają parametryzować struktury. Listing [[ref:code:ex-module-system-usage]] prezentuje przykład wykorzystania systemu modułowego języka =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania systemu modułowego języka \texttt{FOOF}.}}
#+latex: \label{code:ex-module-system-usage}
#+begin_src scheme
(structure A
 (define (foo x)
   (+ 23 x)))

(module (B a)
  (define (bar)
    (a.foo 5)))

(let ((b (B A)))
  (display (b.bar))) ;; Wyświetla liczbę 28
#+end_src
#+latex: \end{listing}

W przykładzie definiowana jest struktura =A= dostarczającą funkcję =foo= oraz moduł (odpowiednik funktora) =B= parametryzowany przez submoduł =a=. Następnie, tworzona jest instancja modułu =B=, wykorzystując zdefiniowaną uprzednio strukturę =A=, i używana w dalszej części programu. Korzystanie z sytemu modułowego jest ułatwione, dzięki specjalnej składni dostępu do zawartości modułu =module.member=.

System ten pozwala w łatwy sposób zarządzać zależnościami modułów - wystarczy zmienić parametr przekazany przy tworzeniu instancji modułu =B= na inną strukturę, bez modyfikacji jego definicji, by osiągnać zamierzone cele. Funkcjonalność ta jest bardzo przydatna przy tworzeniu bibliotek programistycznych, które mogą być parametryzowane modułami służącymi do powszechnych zadań, takimi jak moduł do logowania, lub moduł zawierający parametry konfiguracji aplikacji. W efekcie, biblioteki te nie narzucają z góry implementacji modułów parametryzujących, dzięki czemu mogą być łatwiej zintegrowane z różnymi programami.

Zasadniczą wadą systemu modułowego w zaprezentowanej powyżej formie, jest konieczność istnienia osobnej fazy *linkowania*, czyli tworzenia instancji modułów. Problem ten został szczegółowo przeanalizowany w [[cite:Gasbichler2006]], skutkując stworzeniem notacji /interfejsów modułów/ ułatwiającej automatyczną rezolucję zależności. Rozwiązanie to jest dalekie od doskonałego, toteż język =FOOF= stosuje inne podejście opisane w następnej sekcji.

** Inżynieria wiedzy w języku
Ostatnią i zarazem najbardziej zaawansowaną funkcjonalnością języka =FOOF= jest jego wsparcie dla inżynierii wiedzy (ang. /knowledge engineering/), objawiające się umożliwieniem refleksji na podstawie pewnych /informacji/, które zostały odkryte podczas działania programów. Wspomniane, powiązane ze sobą logicznie informacje, czyli *wiedza*, mogą dotyczyć wielu różnych aspektów działania aplikacji i są w dużej mierze uzależnione od domeny rozwiązywanych problemów.

Istnieje wiele metod reprezentacji i przetwarzania wiedzy, które różnią się sposobem dostępu do zdobytych informacji, a co za tym idzie, stosownością do rozwiązywania danych klas problemów [[cite:Wang2013]]. Dlatego też, wybór konkretnej reprezentacji i mechanizmu przetwarzania wiedzy w języku =FOOF= uzależniony jest od pragmatycznego jego zastosowania.

Wiodącym zadaniem inżynierii wiedzy w języku =FOOF= jest realizacja jednego z główych założeń języka, czyli osiągnięcia *świadomości platformy* poprzez zdobycie i udostępnienie wiedzy o platformie sprzętowej i samej aplikacji na niej działającej. Wiedza ta ma stanowić bazę do podejmowania decyzji o rozwoju obliczeń prowadzonych w aplikacji, a także o samej strukturze systemu.

W założeniu ma to umożliwić automatyczną konfigurację i ewolucję rozproszonych aplikacji zbudowanych z wykorzystaniem języka =FOOF=. Na przykład, system inteligentnego domu, po wykryciu podłączenia w odpowiednim pomieszczeniu czujnika temperatury o wyższej dokładności pomiarów niż dotychczasowo dostępna, powinien bez modyfikacji programu, ani ingerencji jego użytkownika, zacząć z niego korzystać. Natomiast, w przypadku katastrofalnego błędu rzeczonego czujnika, system powinien wrócić do korzystania z poprzedniego czujnika.

Literatura związana z tą dziedziną nauki, która zarazem dotyczy systemów rozproszonych o wysokiej heterogeniczności, takich jak Internet Rzeczy, bardzo często wykorzystuje podejście ontologiczne [[cite:Hachem2011, Wang2013, Samimi2014]]. Polega ono na budowie ontologii domenowej na potrzeby systemu, gdzie wiedza jest reprezentowana jako instancje i klasy obiektów powiązanych ze sobią pewnymi zależnościami. Ontologia ta może być następnie odpytywana, a działający w niej algorytm rozumowania (ang. /reasoner/) pozwala odkrywać nowe zależności pomiędzy obiektami.

Rozwiązane to wchodzi w konflikt z założeniami języka =FOOF= przez swoje skomplikowanie, relatywną restrykcyjność i statyczność bazy wiedzy oraz kosztowność obliczeniową, toteż, pomimo niewątpliwych zalet, nie mogło zostać wdrożone. Alternatywnym rozwiązaniem zastosowanym w języku jest podejście regułowe, polegające na reprezentacji wiedzy w formie *faktów* o nienarzuconej strukturze i przetwarzaniu tej wiedzy za pomocą *reguł* weryfikujących ową strukturę. Listing [[ref:code:ex-rbs-usage]] pokazuje podstawowe operacje związane z inżynierią wiedzy dostępne w języku =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania prymitywnych operacji bazy wiedzy w języku.}}
#+latex: \label{code:ex-rbs-usage}
#+begin_src scheme
(whenever set-of-conditions
  (lambda (_)
    (retract! some-fact)
    (assert! another-fact)))
(signal! an-event)
#+end_src
#+latex: \end{listing}

Przykład ten definiuje jedną regułę bez zagłębiania się w szczegóły implementacji systemu regułowego języka =FOOF=. Reguła ta, bazując na spełnialności pewnego zbioru warunków =set-of-conditions= modyfikuje wbudowaną bazę faktów przez *asercję* i *retrakcję* rożnych faktów. Dodatkowo, przykład *sygnalizuje* zaistnienie pewnego zdarzenia =an-event=, co konceptualnie jest tożsame z asercją i późniejszą retrakcją faktu opisującego zajście tego zdarzenia w systemie.

Projekt przewiduje wykorzystanie opisanych powyżej podstawowych operacji oraz wiedzy możliwej do zdobycia podczas kompilacji programów języka =FOOF= poprzez *inferencję* faktów dotyczących struktury ich kodu źródłowego, do rozwiązania opisanego w poprzedniej sekcji problemu linkowania modułów. Rozwiązanie to polega na przetworzaniu inferowanej wiedzy za pomocą zbioru reguł, zwanych kolektywnie *protokołem modułu*, w celu rezolucji zależności je spełniających w sposób automatyczny. Moduły, zamiast dokładnego sprecyzowania swoich zależności, mogą podać protokóły, które są konieczne i wystarczające do poprawnego, wspólnego działania, a system regułowy automatycznie wybierze spełniające je, dostępne submoduły.

* Kompilator języka =FOOF=
- define what a compiler is
- contrast it with interpreters
- mention technology selection & limitations (large project, little time) [cite:Ghuloum2006]
- hint at using Scheme for the boring details (datatypes etc)
- briefly touch on the architecture [cite:Aho2006]
- mention possible bootstrapping

** Architektura kompilatora
#+begin_center
#+label: fig:compilation-phases
#+caption: Schemat poszczególnych faz kompilacji i przykładowych danych będących wynikiem ich działania.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/compilationphases.pdf]]
#+end_center

- describe the diagram shortly [cite:Aho2006] [cite:Ghuloum2006] [cite:Appel1992]
- briefly describe the compilation phases
- list which phases have been actually implemented

** Parser
- briefly describe how Scheme praser works and what it produces [cite:Sperber2010] [cite:Abelson1996]
- hint at a possibility of replacing this with a PEG-based packrat [cite:Hutton1996] [cite:Ford2004]
- note about homoiconicity & quasiquote syntax [cite:Bawden1999]

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Obsługa rozszerzeń składniowych S-wyrażeń w języku \texttt{FOOF}.}}
#+latex: \label{code:ex-syntax-expansion}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Kod źródłowy:
'(some value)
`(a ,b ,@c)
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Po ekspansji:
(quote (some value))
(quasiquote (a (unquote b)
               (unquote-splicing c)))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

** Makro-ekspansja
- describe macroexpantion phase role
- describe the macroexpansion algorithm

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Pseudokod algorytmu makroekspansji w notacji języka \texttt{FOOF}.}}
#+latex: \label{code:macro-expansion-pseudocode}
#+begin_src scheme
(define (macroexpand expression defined-macros)
  (if (and (list? expression)
           (not (quote? expression)))
      (if (macro-defined? (macro-name expression) macros)
          (macroexpand (apply-expander (macro-name expression)
                                       defined-macros
                                       expression)
                       defined-macros)
          (map (lambda (subexpression)
                 (macroexpand subexpression macros))
               expression))
      expression))
#+end_src
#+latex: \end{listing}

- link to the list of available macros
- a step-by-step example of macroexpansion

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład działania algorytmu makroekspansji.}}
#+latex: \label{code:ex-macro-expansion-steps}
#+begin_src scheme
;; Kod źródłowy:
(let* ((a 23)
       (b (+ a 5)))
  (* 2 b))

;; Pierwszy krok makroekspansji:
(let ((a 23))
  (let ((b (+ a 5)))
    (* 2 b)))

;; Drugi krok makroekspansji:
((lambda (a)
   (let ((b (+ a 5)))
     (* 2 b)))
 23)

;; Trzeci krok makroekspansji:
((lambda (a)
   ((lambda (b)
      (* 2 b))
    (+ a 5)))
 23)
#+end_src
#+latex: \end{listing}

- describe why macroexpansion is hardcoded [cite:Gasbichler2006]
- hint at alternative implementations etc

** Obsługa Systemu Modułowego
- describe how modules are handled right now [cite:Gasbichler2006] [cite:Rossberg2015]
- show some examples of macro-expanded structures & modules
- hint at special module access syntax (foo.bar.baz)

** Transformacja /Continuation Passing Style/
- reformat this to fit the narrative

Do tego celu służy technika przekazywania kontynuacji (ang. /Continuation Passing Style/, /CPS/) polegająca na automatycznej transformacji kodu źródłowego programu do formatu, w którym wszystkie funkcje przyjmują dodatkowy argument będący kontynuacją, którą przekazują dalej [[cite:Appel1992]].

Listing [[ref:code:ex-cps-principle]] prezentuje przykład konwersji CPS prostej funkcji.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład konwersji \textit{Continuation Passing Style}.}}
#+latex: \label{code:ex-cps-principle}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Styl aplikatywny:
(lambda (x y)
  (* 2 (+ x y)))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Styl Continuation Passing:
(lambda (x y cont)
  (+& x y
      (lambda (v)
        (*& 2 v cont))))

;; Transformacja wbudowanych funkcji:
(define (+& a b cont)
  (cont (+ a b)))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Po transformacji, funkcja ta przyjmuje dodatkowy argument =cont=, który następnie przekazuje dalej w ciągu obliczeń. Analogicznie, wbudowane funkcje dodawania =+= i mnożenia =*= również przyjmują dodatkowy argument, który wywołują z wynikiem odpowiedniej operacji, powodując aplikację kontynuacji.

W przykładzie można zauważyć doprecyzowanie kolejności wykonywania działań po transformacji CPS - pierwszą wykonaną operacją jest dodawanie, a jego wynik przekazywany jest do, specjalnie w tym celu stworzonej, kontynuacji pośredniej i następnie od operacji mnożenia wraz z kontynuacją =cont= wywołania funkcji.

- describe the algorithm
- note about lazy continuation code generation
- add a comparison example

- describe in detail how to transform simple stuff
- describe in detail how to transform functions (recursion problems & crude solution via mutation [cite:German1995], [cite:Kaser1993], [cite:Felleisen1991])

- note on recursion problems & solution via mutation

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład transformacji konstrukcji \textt{letrec}.}}
#+latex: \label{code:cps-letrec}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
'(letrec ((even? (lambda (x)
                   ...
                   odd?
                   ...))
          (odd? (lambda (x)
                  ...
                  even?
                  ...)))
   (even? 7))
#+end_src
#+LaTeX: \columnbreak
#+BEGIN_SRC scheme
(let ((even? nil)
      (odd? nil))
  (set! even? (lambda (x)
                ...
                odd?
                ...))
  (set! odd? (lambda (x)
               ...
               even?
               ...))
  (even? 7))
#+END_SRC
#+LaTeX: \end{multicols}
#+latex: \end{listing}

- mention the need to support uprocs & error handling (to be expanded upon in future sections)
- hint at emitting calls to primitive functions =&yield-cont=, =&uproc-error-handler= etc

** Optymalizacja i generacja kodu
- describe & motivate this phase
- mention emitting a subset of both Scheme and FOOF
- contrast it with core erlang (its a true subset, so emitted code is executable in both, kinda) [cite:Carlsson2001] [cite:Carlsson2004]
- hint at further development using LLVM [cite:SomethingAboutLLVM]
- mention a requirement to perform closure conversion or lambda lifting [cite:PeytonJones1992]

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ilustrujący różnice pomiędzy algorytmami lambda-unoszenia oraz konwersji domknięć leksykalnych.}}
#+latex: \label{code:lambda-lift-vs-closure-conv}
#+begin_src scheme
;; Oryginalny kod źródłowy:
(let* ((x 23)
       (plus-x (lambda (n)
                (+ n x))))
  (plus-x 5))
#+end_src
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Lambda-unoszenie:
(define (plus-x x n)
  (+ n x))

(let* ((x 23))
  (plus-x x 5))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Konwersja domknięć-leksykalnych:
(define __lambda0 (self n)
  (+ n (&value-of self 'x)))

(let* ((x 23)
       (plus-x (&closure __lambda0
                        'x x)))
  (&apply plus-x 5))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

- add a code example contrasting closure conversion and lambda lifting
- mention other optimizations (partial evaluation, constant folding and such)

* Środowisko uruchomieniowe języka
- briefly touch on the architecture
- mention Scheme bootstrap

** Architektura środowiska uruchomieniowego
#+begin_center
#+label: fig:rt-architecture
#+caption: Schemat architektury środowiska uruchomieniowego języka =FOOF=.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/rtarchitecture.pdf]]
#+end_center

- describe various parts
- mention that this is single threaded and requires forking for real concurrency
- hint at in-depth description of RBS implementation in a future section

** Implementacja podstawowych typów danych
- describe scheme bootstrap [cite:Sperber2010]
- describe equivalence of various constructs such as lambdas

** Implementacja kontynuacji
- describe how continuations are handled without getting into CFS (returning cont + hole aka trampoline, contrast to how G-machine/TIM reductions work) [cite:Appel1992] [cite:PeytonJones1992]
- add a code example with step-by-step execution
- hint at debugging potential using step by step continuation execution with debug info inbetween

** Implementacja obsługi wyjątków
- describe how continuations are used for error handling - handle & raise
- note about restarts
- note about implementing letcc using handle & raise ?

** Implementacja procesów
- add a diagram of the uProc context - only include status, cont & handler registers
#+begin_center
#+label: fig:uproc-processes
#+caption: Schemat kontekstu procesu obrazujący rejestry niezbędne do jego działania.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uprocprocesses.pdf]]
#+end_center

- describe uProc context registers
- describe how trampolines play into this scheme (recall =&yield-cont=)
- contrast trampolines with corutines (more suitable in CPS) and yielding (done implicitly) [cite:Moura2009]
- describe how error handling is implemented (recall =&uproc-error-handler= etc)
- contrast with erlang [cite:Armstrong1996]

** Harmonogramowanie procesów
#+begin_center
#+label: fig:uproc-cfs
#+caption: Dodatkowe rejestry kontekstu mikroprocesu wymagade do implementacji algorytmu /Completely Fair Scheduler/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uproccfs.pdf]]
#+end_center

- describe the Completely Fair Scheduler [cite:Pabla2009]
- add pseudocode listing showing the algorithm
- describe uProc context switching
- contrast current impl with previous one (lack of wait list - notifications, heaps instead of RBT, number of reductions instead of time) [cite:Sedgewick2008]
- contrast with erlang [cite:Armstrong1996]

** Implementacja Modelu Aktorowego
- describe actor model briefly [cite:Hewitt1973] [cite:Clinger1981]

#+begin_center
#+label: fig:uproc-actor-model
#+caption: Dodatkowe rejestry kontekstu mikroprocesu wymagade do implementacji Modelu Aktorowego.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uprocactormodel.pdf]]
#+end_center

- describe modifications to the runtime required by actor model (*current-uproc*, uproc list, context fields)
- describe implementation of various actor model primitives

#+begin_center
#+label: fig:msg-send
#+caption: Diagram obrazujący efekty przekazywania wiadomości pomiędzy mikroprocesami.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/msgsend.pdf]]
#+end_center

- add some code examples and discussion of its effects and what happens
- contrast with erlang [cite:Armstrong1996]

** Dystrybucja obliczeń
- difference between concurrency & distribution
- describe modifications to the runtime in order to support distribution
- hint about using a simple protocol
- hint about moving this into stdlib

* Reprezentacja i przetwarzanie wiedzy
- describe how this needs a separate section
- elaborate on different ways of knowledge representation [cite:Wang2013] [cite:Barnaghi2012] [cite:Hachem2011] [cite:SomethingAboutProlog] [cite:SomethingAboutRBS]

** Reprezentacja wiedzy w języku
#+begin_center
#+label: fig:fact-rule-store
#+caption: Schemat działania wbudowanych baz faktów i reguł.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/factrulestore.pdf]]
#+end_center

- describe facts - signalling, assertion & retraction
- describe rules briefly - adding & disabling, triggering

** Algorytm Rete
- describe in detail the algorithm [cite:Forgy1982]

#+begin_center
#+label: fig:rete-network-merge
#+caption: Schemat łączenia podsieci w algorytmie /Rete/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/retemerge.pdf]]
#+end_center

- describe briefly its history [cite:Forgy1979]
- Rete vs naïve approach (vs CLIPS or similar ?)
- add a benchmark diagram showing how Rete is better
- contrast it with other algorithms [cite:Miranker1987]

** Implementacja Rete - wnioskowanie w przód
- describe what forward-chaining is
- describe naïve Rete - no network merging
- hint that this might be a good thing (future section)
- describe all the nodes [cite:Forgy1982]

** Implementacja wnioskowania wstecz
- describe what backward-chaining is
- describe fact store in detail - linear, in-memory database
- querying fact store = create a rule and apply all known facts to it

** Integracja z Systemem Uruchomieniowym
- describe how it sucks right now (notify-whenever instead of generic whenever, logic rule removal)
- describe possible integration with the module system (fact inference)
- describe possible representation of rules by autonomus processes [cite:Gupta1986]

#+begin_center
#+label: fig:distributed-rete
#+caption: Schemat działania rozproszonej wersji algorytmu /Rete/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/distributedrete.pdf]]
#+end_center

- hint at movig the implementation to the stdlib

* Podsumowanie
#+latex: \label{sec:outro}

- reiterate the goal of the thesis
- state how well has it been achieved

** Kompilator języka =FOOF=
- needs better optimizations
- needs better error handling

** Środowisko uruchomieniowe
- needs more stuff
- needs macroexpansion
- needs to drop RBS and move it into stdlib

** Przyszłe kierunki rozwoju
- more datatypes
- native compilation via LLVM
- bootstrapping compiler
- librarized RBS
- librarized distribution with data encryption & ACLs
- data-level paralellism

# The bibliography
#+begin_latex
\bibliographystyle{ieeetr}
\bibliography{bibs}
#+end_latex

#+latex: \appendix
* Gramatyka języka =FOOF=
#+LaTeX: \label{sec:foof-grammar}
- concrete language grammar in PEG or BNF

* Przykładowe programy
#+LaTeX: \label{sec:foof-examples}
Poniżej zaprezentowano przykładowe programy w języku =FOOF= i krótki opis ich działania. Programy mogą zostać skompilowane i uruchomione za pomocą udostępnionego interfejsu kompilatora i środowiska uruchomieniowego języka. W konsoli systemu należy w tym celu wywołać odpowiednio funkcje =compile= i =run= podając interesujący program jako parametr, na przykład:

#+BEGIN_EXAMPLE
> (compile 'program)
> (run 'program)
#+END_EXAMPLE

** Hello world!
Program definuje funkcję =hello= obrazującą podstawowe operacje języka i następnie wywołuje ją z jednym parametrem. Po uruchomieniu program powoduje wypisanie wiadomości =Hello world!= na ekranie komputera.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Popularny program \textit{Hello world!}.}}
#+latex: \label{code:ex-hello-world}
#+begin_src scheme
(define (hello world)
  (if (= nil world)
      (raise 'nope)
      (do (display "Hello ")
          (display world)
          (display "!")
          (newline))))

(hello "world")
#+end_src
#+latex: \end{listing}

** Funkcja Fibonacciego
Program prezentuje definicję funkcji Fibonacciego z wykorzystaniem konstrukcji =letrec=, służącej do definiowania funkcji rekursywnych. Następnie program oblicza wynik funkcji Fibonacciego dla liczby 23.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Definicja funkcji Fibonacciego.}}
#+latex: \label{code:ex-fibonacci}
#+begin_src scheme
(letrec ((fib (lambda (n)
                (if (< n 2)
                    n
                    (+ (fib (- n 1))
                       (fib (- n 2)))))))
  (fib 23))
#+end_src
#+latex: \end{listing}

** Obsługa błędów
Program prezentuje wykorzystanie wbudowanego w język systemu obsługi błędów. Deklarowana jest procedura obsługi błędów, która restartuje obliczenia z nową wartością. Następnie program dwukrotnie sygnalizuje wystąpienie błędu. Wynikiem działania programu jest liczba 24.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Zastosowanie wbudowanego mechanizmu obsługi błędów.}}
#+latex: \label{code:ex-error-handling}
#+begin_src scheme
(* 2 (handle (raise (raise 3))
             (lambda (e restart)
               (restart (* 2 e)))))
#+end_src
#+latex: \end{listing}

** Model Aktorowy
Program korzysta z dwóch komunikujących się procesów do zobrazowania sposobu wykorzystania zaimplementowanego w języku Modelu Aktorowego. Efektem działania programu jest wypisanie wiadomości =Hello world!= na ekranie komputera.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie prymitywnych operacji Modelu Aktorowego.}}
#+latex: \label{code:ex-actor-model}
#+begin_src scheme
(let ((pid (spawn (lambda ()
                    (let ((msg (recv)))
                      (display (cdr msg))
                      (newline)
                      (send (car msg) " world!"))))))
  (send pid (cons (self) "Hello"))
  (display (recv))
  (newline))
#+end_src
#+latex: \end{listing}

** Współbieżne obliczenia funkcji Fibonacciego
Program definiuje funkcję Fibonacciego oraz dodatkową funkcję wyświetlającą informacje o systemie. Następnie tworzone są trzy procesy współbieżnie obliczające wartość funkcji Fibonacciego dla liczby 30. Program periodycznie wyświetla różne informacje o działających procesach.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Równoległe obliczanie funkcji Fibonacciego.}}
#+latex: \label{code:ex-parallel-fibonacci}
#+begin_src scheme
(letrec ((fib (lambda (n)
                (if (< n 2)
                    n
                    (+ (fib (- n 1))
                       (fib (- n 2))))))
         (monitor (lambda ()
                    (task-info)
                    (sleep 2000)
                    (monitor))))
  (spawn (lambda ()
           (fib 30)))
  (spawn (lambda ()
           (fib 30)))
  (spawn (lambda ()
           (fib 30)))
  (monitor))
#+end_src
#+latex: \end{listing}

** System modułowy
Program definiuje dwa moduły - =logger= oraz =test=. Moduł =test= wymaga do działania implementacji modułu logowania. Program tworzy instancję modułu =logger= i następnie tworzy instancję modułu =test= wykorzystując uprzednio zdefiniowany moduł logowania. Efektem działania programu jest wypisanie dwóch wiadomości na ekranie komputera. Wiadomości są odpowiednio sformatowane przez moduł =logger=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wbudowanego systemu modułowego.}}
#+latex: \label{code:ex-module-system}
#+begin_src scheme
(module (logger)
  (define (log level string)
    (display "[")
    (display level)
    (display "] ")
    (display string)
    (newline))

  (define (debug string)
    (log 'DEBUG string))

  (define (info string)
    (log 'INFO string))

  (define (warn string)
    (log 'WARN string))

  (define (error string)
    (log 'ERROR string)))

(module (test logger)
  (define (do-something)
    (logger.info "doing something")
    (logger.error "failed badly!")))

(let ((t (test (logger))))
  (t.do-something))
#+end_src
#+latex: \end{listing}

** Wnioskowanie w przód
Program prezentuje wykorzystanie wbudowanego w język systemu regułowego. Definiowane są trzy funkcje, jedna z nich co pewien czas sygnalizuje zajście pewnego zdarzenia - upływ czasu. Druga funkcja oczekuje notyfikacji od systemu regułowego i wyświetla informacje o przechwyconych zdarzeniach. Trzecia funkcja, jest pomocniczą funkcją wyświetlającą informacje o procesach uruchomionych w systemie. Następnie program definiuje prostą regułę i uruchamia wszystkie niezbędne procesy.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wbudowanego systemu regułowego.}}
#+latex: \label{code:ex-forward-chaining}
#+begin_src scheme
(letrec ((monitor (lambda ()
                    (task-info)
                    (sleep 10000)
                    (monitor)))
         (timer (lambda (t)
                  (signal! `(curr-time ,t))
                  (sleep 1000)
                  (timer (+ t 1))))
         (listen (lambda ()
                   (let ((t (recv)))
                     (display "Current time: ")
                     (display (cdr (car t)))
                     (newline)
                     (listen)))))
  (spawn (lambda () (timer 0)))
  (notify-whenever (spawn (lambda ()
                            (listen)))
                   '(curr-time ?t))
  (monitor))
#+end_src
#+latex: \end{listing}

#+LaTeX: \pagebreak
** Obsługa złożonych zdarzeń
Program działa podobnie do przykładu z listingu [[ref:code:ex-forward-chaining]]. Definiowana jest złożona reguła, która notyfikuje proces nasłuchujący jedynie, gdy wartości powiązane z faktami =foo= oraz =bar= osiągają odpowiednie wartości.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Zastosowanie wbudowanego systemu regułowego do obsługi złożonych zdarzeń.}}
#+latex: \label{code:ex-complex-events}
#+begin_src scheme
(letrec ((monitor (lambda ()
                    (task-info)
                    (sleep 10000)
                    (monitor)))
         (notify (lambda (prefix t)
                   (assert! `(notify ,prefix ,(random)))
                   (sleep t)
                   (notify prefix t)))
         (listen (lambda ()
                   (let ((m (recv)))
                     (display "Complex event: ")
                     (display m)
                     (newline)
                     (listen)))))
  (notify-whenever (spawn listen)
                   '(filter (and (?notify foo ?foo)
                                 (?notify bar ?bar))
                            (>= ?foo 0.5)
                            (< ?foo 0.75)
                            (<= ?bar 0.1)))
  (spawn (lambda ()
           (notify 'foo 1000)))
  (spawn (lambda ()
           (notify 'bar 5000)))
  (monitor))
#+end_src
#+latex: \end{listing}

** Wnioskowanie wstecz
Program prezentuje wykorzystanie wnioskowania wstecz wbudowanego w język systemu regułowego. Na bazie faktów wykonywany jest szereg operacji, a następnie program odpytuje bazę faktów o wartości, dla których wystąpiły fakty =foo= oraz =bar=. Wynikiem działania programu jest asocjacja =(?value . 2)=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wnioskowania wstecz.}}
#+latex: \label{code:ex-backward-chaining}
#+begin_src scheme
(assert! '(foo 1))
(assert! '(foo 2))
(assert! '(foo 3))
(assert! '(bar 2))
(assert! '(bar 3))
(retract! '(foo 2))
(signal! '(foo 4))

(select '(and (foo ?value)
              (bar ?value)))
#+end_src
#+latex: \end{listing}

* Spis wbudowanych funkcji języka =FOOF=
- list contents of bootstrap.scm
- describe what =&make-structure=, =&yield-cont= etc do

* Spisy rysunków i fragmentów kodu
#+latex: \label{sec:misc}

#+begin_latex
\begingroup
  \listoffigures
  \pagebreak
  \listofmylisting
\endgroup
#+end_latex
