# ###############################################################################
#+TITLE:
#+AUTHOR: Kajetan Rzepecki
#+DATE: 2015
#+LANGUAGE: pl
#
#+STARTUP: content
#+EXPORT_SELECT_TAGS: export
#+LaTeX_CLASS: aghdpl
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt]
#+LaTeX_HEADER: \usepackage[polish]{babel}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{multicol}
#+LATEX_HEADER: \usepackage[nottoc, notlof, notlot]{tocbibind}
#+OPTIONS: tags:nil, todo:nil, toc:nil
# ###################

# Helpers & Stuff
#+begin_src emacs-lisp :exports none
  (setq org-export-latex-title-command "")
  (add-to-list 'org-latex-classes
               '("aghdpl"
                 "\\documentclass{aghdpl}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))
  (setq org-latex-classes (cdr org-latex-classes))
#+end_src

# AGH setup:
#+LATEX_HEADER: \shortauthor{K. Rzepecki}
#+LATEX_HEADER: \degreeprogramme{Informatyka}

#+LATEX_HEADER: \thesistype{Praca dyplomowa magisterska}

#+LATEX_HEADER: \titlePL{Projekt języka programowania wspierającego przetwarzanie rozproszone na platformach heterogenicznych.}
#+LATEX_HEADER: \titleEN{Design of a programming language with support for distributed computing on heterogenous platforms.}

#+LATEX_HEADER: \shorttitlePL{Projekt języka programowania wspierającego przetwarzanie rozproszone \dots}
#+LATEX_HEADER: \shorttitleEN{Design of a programming language with support for distributed computing \dots}

#+LATEX_HEADER: \supervisor{dr inż. Piotr Matyasik}

#+LATEX_HEADER: \department{Katedra Informatyki Stosowanej}

#+LATEX_HEADER: \faculty{Wydział Elektrotechniki, Automatyki,\protect\\[-1mm] Informatyki i Inżynierii Biomedycznej}

#+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję opiekunowi pracy za wsparcie merytoryczne oraz dobre rady edytorskie pomocne w tworzeniu pracy.}
# #+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję Lucynie oraz siostrze Alicji za cierpliwość i wsparcie podczas tworzenia pracy dyplomowej.}

# Title pages & table of contents:
#+begin_latex
\titlepages
\tableofcontents
#+end_latex

# List of Listings specific:
#+begin_latex
\newcommand{\listlistingname}{\bfseries\Large{Spis listingów}}
\newlistof[chapter]{mylisting}{mlol}{\listlistingname}
\newcommand{\mylisting}[1]{%
  \refstepcounter{mylisting}%
  #1%
  \addcontentsline{mlol}{figure}
    {\protect\numberline{\thechapter.\thelisting}#1}\par%
}
\renewcommand{\cftbeforemloltitleskip}{20mm}
\renewcommand{\cftaftermloltitleskip}{5mm}
#+end_latex

* Wstęp
#+latex: \label{sec:intro}

Tematem pracy jest projekt i implementacja języka programowania wspierającego /przetwarzanie współbieżne/ i umożliwiającego tworzenie /systemów rozproszonych/ działających na /platformach heterogenicznych/.

Przetwarzanie współbieżne polega na podziale obliczeń na wiele procesów działających jednocześnie i konkurujących ze sobą o dostęp do ograniczonej ilości zasobów [[cite:McKenney2015]]. Procesy te mogą zostać rozproszone na wiele fizycznych maszyn, zachowując jednocześnie komunikację pomiędzy nimi, tworząc tym samym jeden koherentny system rozproszony [[cite:Tanenbaum2006]].

Projektowany język programowania powinien więc udostępniać przejrzystą i ogólną notację umożliwiającą definiowanie komunikujących się procesów, jednocześnie pozostając językiem ogólnego przeznaczenia. Dodatkowym wymogiem jest prostota przy zachowaniu ekspresywności - język ten powinien być zbudowany w oparciu o niewielką liczbę ortogonalnych, dobrze współgrających ze sobą mechanizmów, które pozwalają na implementację szerokiej gamy funkcjonalności [[cite:Backus1978]].

#+begin_center
#+label: fig:lang-parts
#+caption: Schemat interakcji poszczególnych elementów języka.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/langparts.pdf]]
#+end_center

W tym celu wymagane jest stworzenie kompilatora, czyli programu transformującego kod źródłowy języka programowania na format możliwy do uruchomienia w pewnym środowisku uruchomieniowym (ang. /runtime system/). Na środowisko takie zazwyczaj składa się zestaw podstawowych procedur wspólnych i niezbędnych do działania każdego programu. Schemat interakcji poszczególnych elementów projektu zaprezentowano na schemacie [[fig:lang-parts]].

Ostatnim wymogiem postawionym przed projektowanym językiem, jest wyjście naprzeciw licznym problemom występującym w systemach rozproszonych, w szczególności problemowi /heterogeniczności/, co umotywowano w następnej sekcji.

** Motywacja pracy
Tworzenie systemów rozproszonych jest zadaniem bardzo trudnym i wymaga wykorzystania specjalnie do tego przeznaczonych narzędzi - języków programowania, systemów bazodanowych i infrastruktury sieciowej. Na przestrzeni lat zidentyfikowano wiele kluczowych problemów manifestujących się we wszystkich systemach rozproszonych niezależnie od ich przeznaczenia. Tanenbaum oraz Van Steen w [[cite:Tanenbaum2006]] wymieniają nestępujące problemy:

- *dostępność* - systemy rozproszone działają zwykle na wielu odrębnych maszynach, istotnym jest więc zachowanie dostępu do wspólnych zasobów z każdej części systemu,

- *przezroczystość dystrybucji* - istotnym jest również ukrycie fizycznego rozproszenia procesów i zasobów, dzięki czemu system rozproszony z zewnątrz stanowi jedną, koherentną całość,

- *otwartość* - polega na standaryzacji komunikacji pomiędzy poszczególnymi częściami systemu, dzięki czemu możliwe jest dodawanie nowych elementów bez ingerencji w pozostałe,

- *skalowalność* - systemy rozproszone powinny umożliwiać płynną zmianę ilości zasobów, być dostępne dla użytkowników z wielu lokacji geograficznych oraz umożliwiać łatwe zarządzanie niezależnie od ich rozmiaru.

Warto zauważyć, iż /skalowalność/ jest przywoływana w folklorze programistycznym nieproporcjonalnie często, natomiast, istnieje wiele równie trudnych problemów, którym przeznacza się znacznie mniej uwagi, takich jak:

- *bezpieczeństwo systemu* - polega na kontroli dostępu do zasobów; w zależności od przeznaczenia systemu rozproszonego, jest najważniejszym aspektem jego budowy,

- *odporność na błędy* - polega na reagowaniu na zmiany (w szczególności wystąpienie błędów) zachodzące w systemie i podejmowaniu odpowiednich akcji w razie ich wystąpienia,

- *heterogeniczność* - polega na zróżnicowaniu platform sprzętowych wchodzących w skład fizycznej części systemu rozproszonego, a także poszczególnych logicznych części systemu.

Heterogeniczność jest problemem szczególnie trudnym, który powoli nabiera znaczenia wraz z pojawieniem się inicjatyw takich jak *Internet Rzeczy* (ang. /Internet of Things/) [[cite:Holler2014]], gdzie systemy rozproszone zbudowane są z dużej ilości bardzo zróżnicowanych maszyn. Maszyny te cechują się różną architekturą sprzętową, ilością zasobów, a także przeznaczeniem i funkcjonalnościami, które realizują i umożliwiają.

Na schemacie [[fig:hetero-iot]] przedstawiony został przykład heterogeniczności platformy sprzętowej w kontekście Internetu Rzeczy. Klient, korzystając z centralnego komputera, uzyskuje dostęp do danych sensorycznych pochodzących z szerokiej gamy różnych czujników i bazując na ich wartości jest w stanie zmieniać zachowanie równie zróżnicowanych efektorów. Całość odbywa się za pośrednictwem dedykowanych sterowników, ułatwiających skalowanie systemu.

#+begin_center
#+label: fig:hetero-iot
#+caption: Przykład systemu opartego o heterogeniczną platformę sprzętową.
#+attr_latex: :width 0.7\textwidth :placement [H]
[[file:./img/heteroiotexample.pdf]]
#+end_center

Każdy element takiego systemu, oznaczony na schemacie różnym kształtem oraz kolorem, reprezentuje maszynę udostępniającą różne zasoby i posiadającą różną fizyczną konstrukcję. Poszczególne elementy często działają w niekompatybilny sposób, w związku z czym wymagane jest wykorzystanie dedykowanych pośredników, których jedynym zadaniem jest /homogenizacja/ systemu.

Problem heterogeniczności dotyka również systemów rozproszonych, które działają na platformach homogenicznych, gdzie fizyczne maszyny są do siebie bardzo zbliżone, a często są komputerami ogólnego przeznaczenia. Przykład takiego systemu, zbudowanego w oparciu o zdobywającą popularność architekturę mikroserwisową [[cite:Richards2015]], został zawarty na schemacie [[fig:hetero-service]].

#+begin_center
#+label: fig:hetero-service
#+caption: Przykład systemu heterogenicznego niezależnie od platformy sprzętowej.
#+attr_latex: :width 0.7\textwidth :placement [H]
[[file:./img/heteroserviceexample.pdf]]
#+end_center

Użytkownik systemu łączy się z głównym serwisem, który następnie komunikuje się z innymi serwisami, realizującymi wymagane przezeń zadania. W celu poprawienia /odporności na błędy/ takiego systemu, w strategicznych miejscach umieszczono serwery zarządzające ruchem (ang. /load-balancer/), których zadaniem, analogicznie do przykładu ze schematu [[fig:hetero-iot]], jest /homogenizacja/ systemu.

W pierszym przypadku heterogeniczność wynika ze zróżnicowania maszyn należących do platformy sprzętowej, natomiast w drugim wynika ona z istnienia mikroserwisów, które realizują pojedyncze, konretnie sprecyzowane funkcjonalności. W obu przypadkach, heterogeniczność systemu prowadzi do powstania innych problemów, takich jak skalowalność i odporność na błędy, oraz konieczności wykorzystania dodatkowych elementów mających im zaradzić.

Często, sytuacja ta wynika z nieadekwatności narzędzi (w szczególności języków programowania) wykorzystanych do tworzenia systemu. Popularne języki programowania dążą do osiągnięcia *niezalożności od platformy* (ang. /platform independence/) stosując maszyny wirtualne i inne techniki mające na celu homogenizację platformy sprzętowej, kiedy w rzeczywistości osiągają *ignorancję platformy* nie umożliwiając refleksji na jej temat.

Jako alternatywę dla osiągnięcia niezależności od platformy, niniejsza praca wprowadza termin *świadomości platformy* (ang. /platform awareness/), czyli dążenia do udostępnienia wiedzy o strukturze budowanego systemu rozproszonego oraz platformy sprzętowej, na której działa, i umożliwienia refleksji na jej podstawie. Zaprezentowany w dalszej części pracy język programowania, roboczo zwany =FOOF= [fn:: Nazwa pochodzi od difluorku ditlenu, niezwykle reaktywnego, dysruptywnego i niebezpiecznego związku chemicznego, który nie ma zastosowania.], ma być uosobieniem ideologii świadomości platformy.

** Zawartość pracy
- list what is found where in the thesis

* Język =FOOF=
# Language ideology
- simplicity but not crudeness [cite:Backus1978]
- pragmatism [cite:Hoare1973]
- platform awareness
- orthogonal features [cite:Backus1978]
- contrast with Scheme/Lisp (and SML ?) [cite:Sperber2010]

** Podstawowe typy danych
- describe lists - pairs of atoms|lists [cite:McCarthy1960]
- describe numbers
- describe symbols
- describe strings
- describe vectors ?
- describe maps ?

** Funkcje
- a note about lambda calculus [cite:Church1932] [cite:Church1933]
- add a code fragment implementing booleans in lambda calculus ?
- describe lambdas
- mention funarg problem [cite:Abelson1996]
- mention recursion problem [cite:Felleisen1991] [cite:Goldberg2005]
- describe named lambdas aka defines

** Kontynuacje
- describe the notion of a continuation [cite:Reynolds1993]
- briefly describe CPS transformation and comment on code equivalence [cite:Appel1992]
- add a code example of the CPS transform
- hint at greater detail in a future section
- hint at delimited control [cite:Dybvig2005]
- describe exceptions via continuations

** Przetwarzanie współbieżne i rozproszone
- briefly describe AMP vs SMP and contrast it with platform heterogeneity

#+begin_center
#+label: fig:homo-vs-hetero
#+caption: Podstawowe różnice pomiędzy platformami homogenicznymi oraz heterogenicznymi.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/homovshetero.pdf]]
#+end_center

#+begin_center
#+label: fig:amp-vs-smp
#+caption: Podstawowe różnice pomiędzy systemami asymetrycznymi i symetrycznymi.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/ampvssmp.pdf]]
#+end_center

- note that system doesn't need to run on a heterogenous platform to be heterogenous itself
- describe Actor Model [cite:Hewitt1973] [cite:Clinger1981]
- describe processes via continuations (trampolines)
- describe actor model primitives [cite:Hewitt1973]
- comment on adding distribution

** Reprezentacja wiedzy w języku
- describe use cases in the language
- describe various ways of knowledge representation [cite:Hachem2011] [cite:Samimi2014] [cite:Wang2013]
- describe primitive operations
- hint at using an RBS

** Makra
- describe macros
- add some code examples of available macros
- hint at problems of hygiene & add code example [cite:Bawden2000] [cite:Queinnec1996]
- hint at problems of macros & modules coexisting [cite:Gasbichler2006]
- contrast macros with other techniques (fexprs) [cite:Shutt2010]

** System modułowy
- describe the need for a module system [cite:Gasbichler2006]
- describe structures - namespaces for definitions
- describe modules - parameterized structures [cite:Rossberg2015]
- describe units - runnable modules
- describe protocols - a set of capabilities of a module
- hint at protocols & SOA connection ?

* Kompilator języka =FOOF=
- mention technology selection & limitations (large project, little time) [cite:Ghuloum2006]
- mention possible bootstrapping
- briefly touch on the architecture [cite:Aho2006]
- hint at using Scheme for the boring details (datatypes etc)

** Architektura kompilatora
#+begin_center
#+label: fig:compilation-phases
#+caption: Schemat poszczególnych faz kompilacji i przykładowych danych będących wynikiem ich działania.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/compilationphases.pdf]]
#+end_center

- list compilation phases [cite:Aho2006] [cite:Ghuloum2006] [cite:Appel1992]
- list which phases have been actually implemented
- list which phases have been skipped and say why (optimization, code-gen, parsing)

** Parser
- briefly describe how Scheme praser works and what it produces [cite:Sperber2010] [cite:Abelson1996]
- hint at a possibility of replacing this with a PEG-based packrat [cite:Hutton1996] [cite:Ford2004]
- note about special quasiquote syntax [cite:Bawden1999]

** Makro-ekspansja
- describe macroexpantion phase
- describe why macroexpansion is hardcoded [cite:Gasbichler2006]
- list available macros
- show some examples of macro-expanded code

** Obsługa Systemu Modułowego
- describe how modules are handled right now [cite:Gasbichler2006] [cite:Rossberg2015]
- show some examples of macro-expanded structures & modules
- maby combine this with the previous section ?
- maby hint at special module access syntax (foo.bar.baz)

** Transformacja /Continuation Passing Style/
- describe what CPS is [cite:Appel1992] [cite:Kennedy2007]
- describe in detail how to transform simple stuff
- describe in detail how to transform functions (recursion problems & crude solution via mutation [cite:German1995], [cite:Kaser1993], [cite:Felleisen1991])
- describe in detail how to handle exceptions
- describe in detail why this is useful (partial evaluation, constant folding etc) [cite:Bacon2002]
- hint at emitting calls to primitive functions =&yield-cont=, =&uproc-error-handler= etc

** Generacja kodu
- describe how a subset of both Scheme and FOOF is emitted (contrast with Core Erlang) [cite:Carlsson2001] [cite:Carlsson2004]
- describe how Scheme is used for direct code execution
- hint at further development using LLVM [cite:SomethingAboutLLVM]
- mention a requirement to perform closure conversion or lambda lifting [cite:PeytonJones1992]
- add a code example contrasting closure conversion and lambda lifting

* Środowisko uruchomieniowe języka
- briefly touch on the architecture
- mention Scheme bootstrap

** Architektura środowiska uruchomieniowego
#+begin_center
#+label: fig:rt-architecture
#+caption: Schemat architektury środowiska uruchomieniowego języka =FOOF=.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/rtarchitecture.pdf]]
#+end_center

- describe various parts
- mention that this is single threaded and requires forking for real concurrency
- hint at in-depth description of RBS implementation in a future section

** Implementacja podstawowych typów danych
- describe scheme bootstrap [cite:Sperber2010]
- describe equivalence of various constructs such as lambdas

** Implementacja kontynuacji
- describe how continuations are handled without getting into CFS (returning cont + hole aka trampoline, contrast to how G-machine/TIM reductions work) [cite:Appel1992] [cite:PeytonJones1992]
- add a code example with step-by-step execution
- hint at debugging potential using step by step continuation execution with debug info inbetween

** Implementacja procesów
- add a diagram of the uProc context - only include status, cont & handler registers
#+begin_center
#+label: fig:uproc-processes
#+caption: Schemat kontekstu procesu obrazujący rejestry niezbędne do jego działania.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uprocprocesses.pdf]]
#+end_center

- describe uProc context registers
- describe how trampolines play into this scheme (recall =&yield-cont=)
- contrast trampolines with corutines (more suitable in CPS) and yielding (done implicitly) [cite:Moura2009]
- describe how error handling is implemented (recall =&uproc-error-handler= etc)
- contrast with erlang [cite:Armstrong1996]

** Harmonogramowanie procesów
#+begin_center
#+label: fig:uproc-cfs
#+caption: Dodatkowe rejestry kontekstu mikroprocesu wymagade do implementacji algorytmu /Completely Fair Scheduler/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uproccfs.pdf]]
#+end_center

- describe the Completely Fair Scheduler [cite:Pabla2009]
- add pseudocode listing showing the algorithm
- describe uProc context switching
- contrast current impl with previous one (lack of wait list - notifications, heaps instead of RBT, number of reductions instead of time) [cite:Sedgewick2008]
- contrast with erlang [cite:Armstrong1996]

** Implementacja Modelu Aktorowego
- describe actor model briefly [cite:Hewitt1973] [cite:Clinger1981]

#+begin_center
#+label: fig:uproc-actor-model
#+caption: Dodatkowe rejestry kontekstu mikroprocesu wymagade do implementacji Modelu Aktorowego.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uproactormodel.pdf]]
#+end_center

- describe modifications to the runtime required by actor model (*current-uproc*, uproc list, context fields)
- describe implementation of various actor model primitives

#+begin_center
#+label: fig:msg-send
#+caption: Diagram obrazujący efekty przekazywania wiadomości pomiędzy mikroprocesami.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/msgsend.pdf]]
#+end_center

- add some code examples and discussion of its effects and what happens
- contrast with erlang [cite:Armstrong1996]

** Dystrybucja obliczeń
- difference between concurrency & distribution
- describe modifications to the runtime in order to support distribution
- hint about using a simple protocol
- hint about moving this into stdlib

* Reprezentacja i przetwarzanie wiedzy
- describe how this needs a separate section
- elaborate on different ways of knowledge representation [cite:Wang2013] [cite:Barnaghi2012] [cite:Hachem2011] [cite:SomethingAboutProlog] [cite:SomethingAboutRBS]

** Reprezentacja wiedzy w języku
#+begin_center
#+label: fig:fact-rule-store
#+caption: Schemat działania wbudowanych baz faktów i reguł.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/factrulestore.pdf]]
#+end_center

- describe facts - signalling, assertion & retraction
- describe rules briefly - adding & disabling, triggering

** Algorytm Rete
- describe in detail the algorithm [cite:Forgy1982]

#+begin_center
#+label: fig:rete-network-merge
#+caption: Schemat łączenia podsieci w algorytmie /Rete/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/retemerge.pdf]]
#+end_center

- describe briefly its history [cite:Forgy1979]
- Rete vs naïve approach (vs CLIPS or similar ?)
- add a benchmark diagram showing how Rete is better
- contrast it with other algorithms [cite:Miranker1987]

** Implementacja Rete - wnioskowanie w przód
- describe what forward-chaining is
- describe naïve Rete - no network merging
- hint that this might be a good thing (future section)
- describe all the nodes [cite:Forgy1982]

** Implementacja wnioskowania wstecz
- describe what backward-chaining is
- describe fact store in detail - linear, in-memory database
- querying fact store = create a rule and apply all known facts to it

** Integracja z Systemem Uruchomieniowym
- describe how it sucks right now (notify-whenever instead of generic whenever, logic rule removal)
- describe possible integration with the module system (fact inference)
- describe possible representation of rules by autonomus processes [cite:Gupta1986]

#+begin_center
#+label: fig:distributed-rete
#+caption: Schemat działania rozproszonej wersji algorytmu /Rete/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/distributedrete.pdf]]
#+end_center

- hint at movig the implementation to the stdlib

* Podsumowanie
#+latex: \label{sec:outro}

- reiterate the goal of the thesis
- state how well has it been achieved

** Kompilator języka =FOOF=
- needs better optimizations
- needs better error handling

** Środowisko uruchomieniowe
- needs more stuff
- needs macroexpansion
- needs to drop RBS and move it into stdlib

** Przyszłe kierunki rozwoju
- more datatypes
- native compilation via LLVM
- bootstrapping compiler
- librarized RBS
- librarized distribution with data encryption & ACLs
- data-level paralellism

# The bibliography
#+begin_latex
\bibliographystyle{ieeetr}
\bibliography{bibs}
#+end_latex

#+latex: \appendix
* Gramatyka języka =FOOF=
- concrete language grammar in PEG or BNF

* Przykładowe programy
- hello world
- some basic definitions & operations
- fibonacci
- parallell fibonacci
- module system - logger
- error handling - (raise (raise "fight the powa"))
- RBS forward-chaining
- RBS backward-chaining
- task monitor example

* Spis wbudowanych funkcji języka =FOOF=
- list contents of bootstrap.scm
- describe what =&make-structure=, =&yield-cont= etc do

* Spisy rysunków i fragmentów kodu
#+latex: \label{sec:misc}

#+begin_latex
\begingroup
  \listoffigures
  \listofmylisting
\endgroup
#+end_latex
