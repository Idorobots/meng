# ###############################################################################
#+TITLE:
#+AUTHOR: Kajetan Rzepecki
#+DATE: 2015
#+LANGUAGE: pl
#
#+STARTUP: content
#+EXPORT_SELECT_TAGS: export
#+LaTeX_CLASS: aghdpl
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt]
#+LaTeX_HEADER: \usepackage[polish]{babel}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{multicol}
#+LATEX_HEADER: \usepackage[nottoc, notlof, notlot]{tocbibind}
#+OPTIONS: tags:nil, todo:nil, toc:nil
# ###################

# Helpers & Stuff
#+begin_src emacs-lisp :exports none
  (setq org-latex-minted-options
        '(("frame" "leftline") ("linenos" "true") ("mathescape" "true")))

  (setq org-export-latex-title-command "")
  (add-to-list 'org-latex-classes
               '("aghdpl"
                 "\\documentclass{aghdpl}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))

  (setq org-latex-classes (cdr org-latex-classes))
#+end_src

# AGH setup:
#+LATEX_HEADER: \shortauthor{K. Rzepecki}
#+LATEX_HEADER: \degreeprogramme{Informatyka}

#+LATEX_HEADER: \thesistype{Praca dyplomowa magisterska}

#+LATEX_HEADER: \titlePL{Projekt języka programowania wspierającego przetwarzanie rozproszone na platformach heterogenicznych.}
#+LATEX_HEADER: \titleEN{Design of a programming language with support for distributed computing on heterogenous platforms.}

#+LATEX_HEADER: \shorttitlePL{Projekt języka programowania wspierającego przetwarzanie rozproszone \dots}
#+LATEX_HEADER: \shorttitleEN{Design of a programming language with support for distributed computing \dots}

#+LATEX_HEADER: \supervisor{dr inż. Piotr Matyasik}

#+LATEX_HEADER: \department{Katedra Informatyki Stosowanej}

#+LATEX_HEADER: \faculty{Wydział Elektrotechniki, Automatyki,\protect\\[-1mm] Informatyki i Inżynierii Biomedycznej}

#+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję opiekunowi pracy za wsparcie merytoryczne oraz dobre rady edytorskie pomocne w tworzeniu pracy.}
# #+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję Lucynie oraz siostrze Alicji za cierpliwość i wsparcie podczas tworzenia pracy dyplomowej.}

# Font stuff:
#+LATEX_HEADER: \setmainfont{Times New Roman}
#+LATEX_HEADER: \setmonofont{Consolas}

# Title pages & table of contents:
#+begin_latex
\titlepages
\tableofcontents
#+end_latex

# List of Listings specific:
#+begin_latex
\newcommand{\listlistingname}{\bfseries\Large{Spis listingów}}
\newlistof[chapter]{mylisting}{mlol}{\listlistingname}
\newcommand{\mylisting}[1]{%
  \refstepcounter{mylisting}%
  #1%
  \addcontentsline{mlol}{figure}
    {\protect\numberline{\thechapter.\thelisting}#1}\par%
}
\renewcommand{\cftbeforemloltitleskip}{20mm}
\renewcommand{\cftaftermloltitleskip}{5mm}
#+end_latex

* Wstęp
#+latex: \label{sec:intro}

Tematem pracy jest projekt i implementacja języka programowania wspierającego /przetwarzanie współbieżne/ i umożliwiającego tworzenie /systemów rozproszonych/ działających na /platformach heterogenicznych/.

Przetwarzanie współbieżne polega na podziale obliczeń na wiele procesów działających jednocześnie i konkurujących ze sobą o dostęp do ograniczonej ilości zasobów [[cite:McKenney2015]]. Procesy te mogą zostać rozproszone na wiele fizycznych maszyn, zachowując jednocześnie komunikację pomiędzy nimi, tworząc tym samym jeden koherentny system rozproszony [[cite:Tanenbaum2006]].

Projektowany język programowania powinien więc udostępniać przejrzystą i ogólną notację umożliwiającą definiowanie komunikujących się procesów, jednocześnie pozostając językiem ogólnego przeznaczenia. Dodatkowym wymogiem jest prostota przy zachowaniu ekspresywności - język ten powinien być zbudowany w oparciu o niewielką liczbę ortogonalnych, dobrze współgrających ze sobą mechanizmów, które pozwalają na implementację szerokiej gamy funkcjonalności [[cite:Backus1978]].

#+begin_center
#+label: fig:lang-parts
#+caption: Schemat interakcji poszczególnych elementów języka.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/langparts.pdf]]
#+end_center

W tym celu wymagane jest stworzenie kompilatora, czyli programu transformującego kod źródłowy języka programowania na format możliwy do uruchomienia w pewnym środowisku uruchomieniowym (ang. /runtime system/). Na środowisko takie zazwyczaj składa się zestaw podstawowych procedur wspólnych i niezbędnych do działania każdego programu. Schemat interakcji poszczególnych elementów projektu zaprezentowano na schemacie [[fig:lang-parts]].

Ostatnim wymogiem postawionym przed projektowanym językiem, jest wyjście naprzeciw licznym problemom występującym w systemach rozproszonych, w szczególności problemowi /heterogeniczności/, co umotywowano w sekcji [[ref:sec:thesis-motivation]].

** Motywacja pracy
#+LaTeX: \label{sec:thesis-motivation}

Tworzenie systemów rozproszonych jest zadaniem bardzo trudnym i wymaga wykorzystania specjalnie do tego przeznaczonych narzędzi - języków programowania, systemów bazodanowych i infrastruktury sieciowej. Na przestrzeni lat zidentyfikowano wiele kluczowych problemów manifestujących się we wszystkich systemach rozproszonych niezależnie od ich przeznaczenia. Tanenbaum oraz Van Steen w [[cite:Tanenbaum2006]] wymieniają następujące problemy:

- *dostępność* - systemy rozproszone działają zwykle na wielu odrębnych maszynach, istotnym jest więc zachowanie dostępu do wspólnych zasobów z każdej części systemu,

- *przezroczystość dystrybucji* - istotnym jest również ukrycie fizycznego rozproszenia procesów i zasobów, dzięki czemu system rozproszony z zewnątrz stanowi jedną, koherentną całość,

- *otwartość* - polega na standaryzacji komunikacji pomiędzy poszczególnymi częściami systemu, dzięki czemu możliwe jest dodawanie nowych elementów bez ingerencji w pozostałe,

- *skalowalność* - systemy rozproszone powinny umożliwiać płynną zmianę ilości zasobów, być dostępne dla użytkowników z wielu lokacji geograficznych oraz umożliwiać łatwe zarządzanie niezależnie od ich rozmiaru.

Warto zauważyć, iż /skalowalność/ jest przywoływana w folklorze programistycznym nieproporcjonalnie często, natomiast, istnieje wiele równie trudnych problemów, którym przeznacza się znacznie mniej uwagi, takich jak:

- *bezpieczeństwo systemu* - polega na kontroli dostępu do zasobów; w zależności od przeznaczenia systemu rozproszonego, jest najważniejszym aspektem jego budowy,

- *odporność na błędy* - polega na reagowaniu na zmiany (w szczególności wystąpienie błędów) zachodzące w systemie i podejmowaniu odpowiednich akcji w razie ich wystąpienia,

- *heterogeniczność* - polega na zróżnicowaniu platform sprzętowych wchodzących w skład fizycznej części systemu rozproszonego, a także poszczególnych logicznych części systemu.

Heterogeniczność jest problemem szczególnie trudnym, który powoli nabiera znaczenia wraz z pojawieniem się inicjatyw takich jak *Internet Rzeczy* (ang. /Internet of Things/) [[cite:Holler2014]], gdzie systemy rozproszone zbudowane są z dużej ilości bardzo zróżnicowanych maszyn. Maszyny te cechują się różną architekturą sprzętową, ilością zasobów, a także przeznaczeniem i funkcjonalnościami, które realizują i umożliwiają.

Na schemacie [[fig:hetero-iot]] przedstawiony został przykład heterogeniczności platformy sprzętowej w kontekście Internetu Rzeczy. Klient, korzystając z centralnego komputera, uzyskuje dostęp do danych sensorycznych pochodzących z szerokiej gamy różnych czujników i bazując na ich wartości jest w stanie zmieniać zachowanie równie zróżnicowanych efektorów. Całość odbywa się za pośrednictwem dedykowanych sterowników, ułatwiających skalowanie systemu.

#+begin_center
#+label: fig:hetero-iot
#+caption: Przykład systemu opartego o heterogeniczną platformę sprzętową.
#+attr_latex: :width 0.7\textwidth :placement [H]
[[file:./img/heteroiotexample.pdf]]
#+end_center

Każdy element takiego systemu, oznaczony na schemacie różnym kształtem oraz kolorem, reprezentuje maszynę udostępniającą różne zasoby i posiadającą różną fizyczną konstrukcję. Poszczególne elementy często działają w niekompatybilny sposób, w związku z czym wymagane jest wykorzystanie dedykowanych pośredników, których jedynym zadaniem jest /homogenizacja/ systemu.

Problem heterogeniczności dotyka również systemów rozproszonych, które działają na platformach homogenicznych, gdzie fizyczne maszyny są do siebie bardzo zbliżone, a często są komputerami ogólnego przeznaczenia. Przykład takiego systemu, zbudowanego w oparciu o zdobywającą popularność architekturę mikroserwisową [[cite:Richards2015]], został zawarty na schemacie [[fig:hetero-service]].

Użytkownik systemu łączy się z głównym serwisem, który następnie komunikuje się z innymi serwisami, realizującymi wymagane przezeń zadania. W celu poprawienia /odporności na błędy/ takiego systemu, w strategicznych miejscach umieszczono serwery zarządzające ruchem (ang. /load-balancer/), których zadaniem, analogicznie do przykładu ze schematu [[fig:hetero-iot]], jest /homogenizacja/ systemu.

#+begin_center
#+label: fig:hetero-service
#+caption: Przykład systemu heterogenicznego niezależnie od platformy sprzętowej.
#+attr_latex: :width 0.7\textwidth :placement [H]
[[file:./img/heteroserviceexample.pdf]]
#+end_center

W pierszym przypadku heterogeniczność wynika ze zróżnicowania maszyn należących do platformy sprzętowej, natomiast w drugim wynika ona z istnienia mikroserwisów, które realizują pojedyncze, konretnie sprecyzowane funkcjonalności. W obu przypadkach, heterogeniczność systemu prowadzi do powstania innych problemów, takich jak skalowalność i odporność na błędy, oraz konieczności wykorzystania dodatkowych elementów mających im zaradzić.

Często, sytuacja ta wynika z nieadekwatności narzędzi (w szczególności języków programowania) wykorzystanych do tworzenia systemu. Popularne języki programowania dążą do osiągnięcia *niezalożności od platformy* (ang. /platform independence/) stosując maszyny wirtualne i inne techniki mające na celu homogenizację platformy sprzętowej, kiedy w rzeczywistości osiągają *ignorancję platformy* nie umożliwiając refleksji na jej temat.

Jako alternatywę dla osiągnięcia niezależności od platformy, niniejsza praca wprowadza termin *świadomości platformy* (ang. /platform awareness/), czyli dążenia do udostępnienia wiedzy o strukturze budowanego systemu rozproszonego oraz platformy sprzętowej, na której działa, i umożliwienia refleksji na jej podstawie. Zaprezentowany w dalszej części pracy język programowania, roboczo zwany =FOOF= [fn:: Nazwa pochodzi od difluorku ditlenu, niezwykle reaktywnego, dysruptywnego i niebezpiecznego związku chemicznego, który nie ma zastosowania.], ma być uosobieniem ideologii świadomości platformy.

** Zawartość pracy
- list what is found where in the thesis

* Język =FOOF=
#+LaTeX: \label{sec:lang-description}

Niniejszy rozdział szczegółowo opisuje projekt języka programowania =FOOF= począwszy od podstawowych typów danych, przez notację funkcji, kontynuacji i procesów, kończąc na zaawansowanych mechanizmach języka, takich jak przetwarzanie wiedzy i wbudowany system makr. W dodatku [[ref:sec:foof-grammar]] zawarto formalny opis gramatyki języka, natomiast w dodatku [[ref:sec:foof-examples]] zamieszczono kilka przykładowych programów.

Język =FOOF= został zaprojektowany bazując na cennych wskazówkach przedstawionych przez John'a Backus'a w wykładzie wygłoszonym przez niego podczas odbierania Nagrody Turing'a w 1977 roku [[cite:Backus1978]]. Wskazówki te są ponadczasowe i stanowią dobrą podstawę do tworzenia języków programowania, a w dużym skrócie sprowadzają się do następujących punktów:

- *prostota lecz nie surowość* (ang. /simplicity, not crudeness/) - języki programowania powinny cechować się prostotą, lecz nie ograniczać ekspresywności programisty przez brak możliwości zrealizowania pewnych funkcjonalności, a co za tym idzie:

- *ortogonalne funkcjonalności* (ang. /orthogonal features/) - język programowania powinien składać się z niewielkiej liczby dobrze zdefiniowanych i dobrze współgrających mechanizmów, za pomocą których programista jest w stanie łatwo zbudować wszelkie inne potrzebne funkcjonalności.

Oczywiście, zasady te nie są wystarczające do stworzenia funkcjonalnego języka programowania, dlatego kierowano się także *pragmatyzmem*, który w kontekście projektowania języków programowania sprowadza się do podejmowania kompromisów, pomiędzy /matematyczną czystością/ a faktyczną użytecznością potencjalnych funkcjonalności dostarczanych przez język. Podejście to zostało szczegółowo opisane w [[cite:Hoare1973]].

Ze względu na podobne zasady, którymi kierowano się podczas projektowania, język =FOOF= przypomina pod względem składniowym i semantycznym odpowiednio języki *Scheme* (opisany szczegółowo w [[cite:Sperber2010]]) oraz *Standard ML* [[cite:Milner1997]]. Natomiast, cechami odróżniającymi =FOOF= od tych języków są: wsparcie dla programowania współbieżnego oraz wykorzystanie inżynierii wiedzy w celu osiągnięcia /świadomości platformy/ i rozwiązania problemu heterogeniczności systemów rozproszonych.

** Podstawowe typy danych
Listing [[ref:code:basic-data-types]] prezentuje proste typy danych dostępne w języku =FOOF=; są to podstawowe elementy budulcowe programów, które mają swoją reprezentację literałową.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Podstawowe typy danych dostępne w języku \texttt{FOOF}.}}
#+latex: \label{code:basic-data-types}
#+begin_src clojure
23.5
symbol
:symbol
"ciąg znaków"
(1 2 3)
[1 2 3]
{:a 1 :b 2}
#+end_src
#+latex: \end{listing}

Typy te to w kolejności: liczby, symbole, słowa kluczowe i ciągi znaków tekstowych, stanowiące wspólnie klasę wartości atomowych oraz listy pojedynczo-wiązane, wektory i mapy asocjacyjne. Każdy nieatomowy typ danych składa się z określonej liczby podwartości, które mogą być atomowe, lub nieatomowe. Semantyka każdego wymienionego typu danych jest zgodna z analogicznymi konstrukcjami opisanymi w [[cite:Sperber2010]].

Jako, że język =FOOF= jest dialektem języka Lisp, programy kodowane są homoikonicznie przez opisane powyżej typy danych - stosowana jest notacja *S-wyrażeń*, która została wprowadzona w [[cite:McCarthy1960]]. Notacja ta rozmywa granicę pomiędzy programami a danymi, pozwalając programom na manipulację, budowę i transformację innych programów.

Homoikoniczność i notację S-wyrażeń wykorzystano w wielu innych mechanizmach dostępnych w języku, które zostały opisane w dalszej części niniejszego rozdziału, w szczególności w implementacji systemu makr pozwalającego na rozszerzenie składni języka.

** Funkcje
Pierwszym złożonym typem danych, który nie ma reprezentacji literałowej w języku =FOOF= są funkcje. Funkcje są obiektami pierwszej klasy, to znaczy, po stworzeniu podczas działania programu, mogą być wykorzystywane tak jak każdy inny typ danych, a co za tym idzie, mogą być osadzane w listach, przekazywane do innych funkcji, a także z nich zwracane jako wynik obliczeń.

Funkcje zostały zaprojektowane w oparciu o *Rachunek Lambda*, wprowadzony w 1933 roku przez Alonzo Church'a jako alternatywny model logiki i, następnie, prowadzenia obliczeń [[cite:Church1932, Church1933]]. Rachunek ten wprowadza pojęcie *wyrażenia lambda*, które jest ekwiwalentem jednoargumentowych funkcji obecnych języków programowania, oraz szereg zasad substytucji, zwanych redukcjami, pozwalających na uproszczenie zagnieżdżonych wyrażeń lambda. Najważniejszą z wprowadzanych redukcji jest *\beta-redukcja*, która konceptualnie reprezentuje aplikację funkcji z odpowiednimi argumentami i jednocześnie pozwala na prowadzenie obliczeń.

Zasady Rachunku Lambda są fundamentalnie bardzo nieskomplikowane, a mimo to pozwalają na ekspresję skomplikowanych idei, takich jak logika Bool'a, arytmetyka, struktury danych oraz rekurencja. Na listingu [[ref:code:ex-lambda-calculus]] zawarto przykład realizacji logiki boola wraz z kilkoma operatorami logicznymi w czystym Rachunku Lambda.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład implementacji wartości i operatorów logicznych w Rachunku Lambda.}}
#+latex: \label{code:ex-lambda-calculus}
#+BEGIN_SRC text
TRUE := λx.λy.x
FALSE := λx.λy.y

AND := λp.λq.p q p
OR := λp.λq.p p q
NOT := λp.λa.λb.p b a

AND TRUE FALSE
    ≡ (λp.λq.p q p) TRUE FALSE →β TRUE FALSE TRUE
    ≡ (λx.λy.x) FALSE TRUE →β FALSE
#+END_SRC
#+latex: \end{listing}

Wartości logiczne kodowane są jako wyrażenia lambda konsumujące dwa argumenty i wybierające odpowiednio pierwszy z nich, dla logicznej wartości prawdy, lub drugi z nich, dla logicznej wartości fałszu. W podobny sposób kodowane są operatory logiczne, a wynik ich działania obliczany jest przez sukcesywne przeprowadzanie substytucji nazwy argumentu na jego wartość oraz redukowaniu otrzymanych wyrażeń za pomocą \beta-redukcji.

Warto zauważyć, że wyrażenia lambda można interpretować jako tak zwane *domknięcia leksykalne*, czyli tworzone podczas \beta-redukcji otaczającego wyrażenia pary funkcji i map asocjacyjnych odzwierciedlających wartości zmiennych, które występują w ciele domknięcia leksykalnego, a nie są przez nie wprowadzane. Domknięcia leksykalne pozwalają opóźnić substytucję nazw argumentów wyrażeń lambda na odpowiadające im wartości, dzięki czemu są łatwiejsze w implementacji [[cite:PeytonJones1992]]. Listing [[ref:code:closures-at-work]] pokazuje działanie domknięć leksykalnych w notacji języka =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ilustrujący działanie domknięć leksykalnych.}}
#+latex: \label{code:closures-at-work}
#+begin_src scheme
(let* ((x 23)
       (foo (lambda () x)))
  (let ((x 5))
    (display (foo)))) ;; Wyświetla liczbę 23
#+end_src
#+latex: \end{listing}

Funkcja =foo= zaprezentowana na listingu, korzysta z wartości *wolnej zmiennej* =x=, czyli takiej, której nie wprowadza w liście swoich argumentów. W dalszej części programu, funkcja =foo=, pomimo lokalnej zmiany wartości zmiennej =x=, poprawnie zwraca oryginalną jej wartość, ponieważ w momencie jej tworzenia wartość zmiennej =x= została zapisana razem z ciałem funkcji.

Często pojawiającym się problemem związanym z funkcjami wzorowanymi na Rachunku Lambda, jest tak zwany problem *funarg*, polegający na niepoprawnym działaniu programów, które zwracają funkcje jako wynik obliczeń, lub przekazują je jako argumenty innych funcji. Problem ten sprowadza się do niewłaściwego budowania domknięć leksykalnych, co może doprowadzić do przedwczesnego usunięcia wartości zmiennych wolnych. Został on poruszony w [[cite:Abelson1996]].

Kolejnym problemem towarzyszącym funkcjom zrealizowanym jako domknięcia leksykalne jest nietrywialna implementacja rekurencji, wynikająca z ustalonej kolejności wykonywania działań - tworzenie domknięcia leksykalnego funkcji rekurencyjnej jest uzależnione od jej uprzedniego istnienia, co prowadzi do sprzeczności.

Oryginalna praca wprowadzająca Rachunek Lambda w celu osiągnięcia rekurencji wykorzystuje rachunek kombinatorów [[cite:Church1932]], a w szczególności *kombinator Y*. Sposób działania tego kombinatora został szczegółowo opisany w [[cite:Felleisen1991]], natomiast problem i propozycję implementacji rekurencji szerzej opisano w [[cite:Rzepecki2015]].

** Kontynuacje
#+LaTeX: \label{sec:continuations-description}

Kolejnym mechanizmem będącym integralną częścią języka =FOOF= są kontynuacje, czyli abstrakcyjne reprezentacje przepływu sterowania programów, które pozwalają jednoznacznie określić kolejność wykonywania obliczeń.

Kontynuacje można interpretować jako ciąg obliczeń pozostałych do wykonania z punktu widzenia danego miejsca programu, który został *reifikowany* jako funkcja i udostępniony z poziomu wykonywanego programu. W efekcie, programy mogą zadecydować by zrestartować obliczenia od pewnego momentu, albo wręcz przeciwnie, przerwać je odrzucając wartości pośrednie.

Jako, że jest to mechanizm skomplikowany, który był odkrywany wielokrotnie [[cite:Reynolds1993]], często nieświadomie, istnieje wiele jego wersji i sposobów implementacji, a w związu z czym nie jest on powszechnie dostępny jako standardowa funkcjonalność popularnych języków programowania. Ze względu na swoje właściwości opisane powyżej, kontynuacje są częściej stosowane w implementacjach kompilatorów języków programowania, jako format pośredni reprezentacji programów [[cite:Appel1992]].

Języki programowania, które korzystają z kontynuacji czasem udostępniają je jako obiekty pierwszej klasy, które mogą być traktowane w taki sam sposób jak inne typy danych. Służy do tego wiele zróżnicowanych operacji prymitywnych, które różnią się semantyką. W przypadku języka Scheme operacja prymitywna służąca do przechwytywania kontynuacji to =call-with-current-continuation= (=call/cc=) [[cite:Sperber2010]], natomiast w języku Standard ML służy ku temu konstrukcja =letcc= [[cite:Harper1998]].

Istnieją także sposoby komponowania kontynuacji, bazujące na tak zwanych kontynuacjach ograniczonych (ang. /delimited continuations/), które wykorzystują większą liczbę operacji prymitywnych, na przykład =shitf= oraz =reset= opisane w [[cite:Dybvig2005]], w celu zapewnienia większej kontroli nad przepływem sterowania programu. Listing [[ref:code:ex-early-return]] demonstruje sposób wykorzystania kontynuacji w języku =FOOF= w celu implementacji wczesnego powrotu z funkcji.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania kontynuacji w języku \texttt{FOOF}.}}
#+latex: \label{code:ex-early-return}
#+begin_src scheme
(lambda (x)
  (letcc return
    ...
    (return 23)
    ...))
#+end_src
#+latex: \end{listing}

Dzięki możliwości przechwycenia kontynuacji, program jest w stanie przedwcześnie zakończyć działanie funkcji z obliczoną wartością. Kontynuacje dostępne są bezpośrednio, dzięki konstrtukcjom =letcc=, =shift= oraz =reset=, a także pośrednio, dzięki gamie innych mechanizmów kontroli przepływu sterowania, takich jak obsługa błędów, czy multiprocessing.

Alternatywną metodą osiągnięcia podobnej funkcjonalności do tej oferowanej przez kontynuacje jest wykorzystanie /koprocedur/, czyli generalizacji funkcji pozwalającej na bezpieczne przerwanie działania w określonych miejscach i późniejszego do nich powrotu [[cite:Moura2009]]. Rozwiązanie to wymaga jednak sprecyzowania miejsc powrotu przez programistę, zwykle za pomocą konstrukcji =yield= lub =async/await=, co jest mniej ekspresywne niż wykorzystanie pełnych kontynuacji.

** Obsługa błędów
Jednym z najważniejszych mechanizmów, jakie powinien udostępniać język programowania, jest mechanizm obsługi błędów i sytuacji wyjątkowych.

Język =FOOF= zapewnia mechanizm obsługi błędów, który bazuje na kontynuacjach, w związku z czym charakteryzuje się bardzo dużą ekspresywnością. Mechanizm ten umożliwia, analogicznie do większości popularnych języków programowania, zadeklarowanie procedury obsługi zdarzeń wyjątkowych za pomocą konstukcji =handle= oraz sygnalizację zajścia takiego zdarzenia poprzez =raise=.

W przeciwieństwie do większości języków programowania, mechanizm dostępny w języku =FOOF= pozwala na kontynuowanie obliczeń w miejscu wystąpienia błędu z nową wartością, obliczoną w zadeklarowanej procedurze obsługi błędu. Przykład ilustrujący taki schemat został zaprezentowany na listingu [[ref:code:ex-restarts]].

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania mechanizmu obsługi błędów.}}
#+latex: \label{code:ex-restarts}
#+begin_src scheme
(handle (do ...
            (raise 'error) ;; Błąd w trakcie wykonywania obliczeń.
            ...)
        (lambda (error restart)
          ...
          (restart new-value))) ;; Kontynuacja z nową wartością.
#+end_src
#+latex: \end{listing}

Przykładowy program deklaruje procedurę obsługi sytuacji wyjątkowej, a następnie przechodzi do kosztownych obliczeń, które przedwcześnie sygnalizują wystąpienie błędu. Przepływ sterowania zostaje przekazany do zadeklarowanej procedury obsługi sytuacji wyjątkowej, która decyduje się zrestartować obliczenia dostarczając im nową, poprawną wartość. Następnie, program wraca do punktu wystąpienia błędu i kontynuuje obliczenia wykorzystują nową, poprawną wartość.

** Przetwarzanie współbieżne i rozproszone
Jednym z głównych założeń języka jest wsparcie dla przetwarzania współbieżnego i rozproszonego, dlatego istotnym jest, by abstrakcja to umożliwiająca była prosta, ekspresywna i wygodna w użyciu, ponieważ będzie stanowiła kluczowy element każdego programu, który powstanie w języku =FOOF=. Abstrakcją, która spełnia wszystkie te wymogi jest *Model Aktorowy* zaproponowany przez Carl'a Hewitt'a w 1973 roku [[cite:Hewitt1973]] i rozszerzony o formalny opis semantyki przez Williama Clingera w roku 1981 [[cite:Clinger1981]].

Model Aktorowy bazuje na kilku prostych koncepcjach, takich jak podział programu na wiele działających wspłóbieżnie procesów (aktorów), porozumiewających się poprzez przesyłanie wiadomości, na których podstawie mogą podejmować lokalne decyzje, tworzyć kolejne procesy, lub wysyłać kolejne wiadomości. Listing [[ref:code:ex-actor-model-usage]] prezentuje wszystkie operacje prymitywne udostępniane przez Model Aktorowy.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania prymitywnych operacji Modelu Aktorowego w języku.}}
#+latex: \label{code:ex-actor-model-usage}
#+begin_src scheme
(send (spawn (lambda ()
               (sleep 1000)
               (send (recv) 'message)))
      (self))

(equal? (recv) 'message)
#+end_src
#+latex: \end{listing}

Program ten tworzy nowy proces korzystając z funkcji =spawn=, któremu natychmiastowo wysyła wiadomość za pośrednictwem funkcji =send=, zawierając w niej swój identyfikator =self=, po czym przechodzi do oczekiwania na odpowiedź wywołując funkcję =recv=. Tymczasem, nowopowstały proces zostaje uśpiony na 1000 milisekund (=sleep=) po czym odbiera przesłaną do niego wiadomość i odpowiada na nią wysyłając symbol =message=.

Interfejs ten jest bardzo zbliżony do interfejsu Modelu Aktorowego dostępnego w języku Erlang [[cite:Armstrong1996]] i zaiste był na nim wzorowany. W odróżnieniu od języka Erlang, odbieranie wiadomości nie wykorzystuje dopasowywania wzorców bezpośrednio w prymitywnej operacji =recv=, lecz umożliwia jego osobną implementację. Podobnie, jak w przypadku języka Erlang, projekt przewiduje rozszerzenie listy prymitywnych operacji o identyfikację maszyn, na których działają procesy.

Implementacja Modelu Aktorowego w języku =FOOF= podobnie jak mechanizm obsługi błędów, została oparta o kontynuacje i zostanie opisana szczegółowo w następnych rozdziałach.

** Makra
#+LaTeX: \label{sec:macros-description}

Prawdobodobnie najciekawszą funkcjonalnością języków z rodziny Lisp jest ich podejście do metaprogramowania i generowania kodu. Większość języków z tej rodziny wykorzystuje wersję systemu *makr*, który pozwala rozszerzać składnię języka i tworzyć dialekty domenowe (ang. /domain specific language/) w prosty i przystępny sposób. Język =FOOF= nie jest wyjątkiem i również został wyposażony w system makr.

Listing [[ref:code:ex-macroexpansion]] prezentuje efekt działania *makroekspansji*, czyli substytucji wywołań makr na definicje ich ciał, na przykładzie kilku wbudowanych makr rozszerzających składnię języka =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład działania systemu makr w języku \texttt{FOOF}.}}
#+latex: \label{code:ex-macroexpansion}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Przed makroekspansją:
(and 23 42)



(let ((x 23))
  (display x))


`(4 is ,(* 2 2))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Po makroekspansji:
(if 23
    42
    false)

((lambda (x)
   (display x))
 23)

(list '4 'is (* 2 2))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Efektem makroekspansji jest powstanie semantycznie ekwiwalentnego kodu, który wykorzystuje tylko dobrze zdefiniowane konstrukcje składniowe języka. Warto zwrócić uwagę na ostatni z przykładów, który prezentuje znaną z innych dialektów języka Lisp konstrukcję =quasiquote=. Konstrukcja ta umożliwia budowanie programów w łatwy, wizualny sposób bez konieczności samodzielnego budowania drzew programu z wykorzystaniem funkcji =cons=, =list= i pokrewnych. Szczegółowy opis działania =quasiquote= został zawarty w [[cite:Bawden1999]].

Systemy makr czesto borykają się z problemami *higieniczności* generowanego kodu. Problem ten ilustruje przykład z listingu [[ref:code:macro-hygiene]].

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ilustrujący problem higieniczności systemu makr w języku Scheme.}}
#+latex: \label{code:macro-hygiene}
#+begin_src scheme
(define-macro (unless c . b)
  `(if (not ,c)
       (begin ,@b)
       #void))

(let ((not identity))
  (unless #t
    (display "Hello world!")))
#+end_src
#+latex: \end{listing}

Zdefiniowane zostaje makro =unless=, którego zadaniem jest uruchamianie pewnych obliczeń jedynie, gdy podany warunek nie jest spełniony. W tym celu makro korzysta z konstrukcji =if= oraz funkcji =not=, nie zachowując, niestety, higieniczności, czego dowodzi druga część przykładu - lokalna zmiana wartości zmiennej =not= na funkcję tożsamości powoduje niewłaściwe działanie makra =unless=.

Problem higieniczności jest problemem skomplikowanym i zazwyczaj jego rozwiązanie oznacza poświęcenie części funkcjonalności systemu makr, na przykład poprzez ograniczenie go do translacji szablonów [[cite:Sperber2010]], lub znacznego jego skomplikowania, przez konieczność wprowadzenia hierarchicznej refleksji makroekspansji [[cite:Queinnec1996]]. Niestety, system makr języka =FOOF= pozostawia ten problem otwartym.

Alternatywnym podejściem do problemu metaprogramowania, o którym warto wspomnieć są *f-wyrażenia* (ang. /f-expressions/, /fexprs/), polegające na podziale funkcji na dwa fundamentalne kompotenty - aplikatywny, indukujący ewaluację argumentów oraz operatywny, analogiczny do substytucji nazw argumentów na ich wartości w wyrażeniach lambda Rachunku Lambda [[cite:Shutt2010]]. Podejście to drastycznie komplikuje kompilację kodu źródłowego, w związku z czym nie zostało wykorzystane w języku =FOOF=.

** System modułowy
#+LaTeX: \label{sec:module-system}

W celu umożliwienia podziału kodu źródłowego programów na logicznie związane części i ułatwienia zarządzania nimi, nowoczesne języki programowania często udostępniają systemy modułowe, wraz z niezbędnymi do ich działania rozszerzeniami składniowymi.

Systemy takie, w zależności od języka programowania, na potrzeby którego zostały zaprojektowane, różnią się sposobem działania oraz ekspresywnością. Mniej skomplikowane systemy modułowe polegają na zwyczajnych podstawieniach tekstowych z opcjonalnym wsparciem dla /przestrzeni nazw/ w celu uniknięcia konfliktów identyfikatorów, natomiast bardziej skomplikowane umożliwiają kontrolę dostępu oraz definiowanie zależności pomiędzy poszczególnymi modułami.

System modułowy wykorzystywany w języku =FOOF= jest zbliżony w swojej funkcjonalności do analogicznego systemu języka Standard ML [[cite:Harper1998]], a właściwe jego modyfikacji opisanej w [[cite:Rossberg2015]], gdzie mamy do czynienia ze *strukturami* wiążącymi ze sobą definicje funkcji i zmiennych, oraz *funktorami*, które pozwalają parametryzować struktury. Listing [[ref:code:ex-module-system-usage]] prezentuje przykład wykorzystania systemu modułowego języka =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania systemu modułowego języka \texttt{FOOF}.}}
#+latex: \label{code:ex-module-system-usage}
#+begin_src scheme
(structure A
 (define (foo x)
   (+ 23 x)))

(module (B a)
  (define (bar)
    (a.foo 5)))

(let ((b (B A)))
  (display (b.bar))) ;; Wyświetla liczbę 28
#+end_src
#+latex: \end{listing}

W przykładzie definiowana jest struktura =A= dostarczającą funkcję =foo= oraz moduł (odpowiednik funktora) =B= parametryzowany przez submoduł =a=. Następnie, tworzona jest instancja modułu =B=, wykorzystując zdefiniowaną uprzednio strukturę =A=, i używana w dalszej części programu. Korzystanie z sytemu modułowego jest ułatwione, dzięki specjalnej składni dostępu do zawartości modułu =module.member=.

System ten pozwala w łatwy sposób zarządzać zależnościami modułów - wystarczy zmienić parametr przekazany przy tworzeniu instancji modułu =B= na inną strukturę, bez modyfikacji jego definicji, by osiągnać zamierzone cele. Funkcjonalność ta jest bardzo przydatna przy tworzeniu bibliotek programistycznych, które mogą być parametryzowane modułami służącymi do powszechnych zadań, takimi jak moduł do logowania, lub moduł zawierający parametry konfiguracji aplikacji. W efekcie, biblioteki te nie narzucają z góry implementacji modułów parametryzujących, dzięki czemu mogą być łatwiej zintegrowane z różnymi programami.

Zasadniczą wadą systemu modułowego w zaprezentowanej powyżej formie, jest konieczność istnienia osobnej fazy *linkowania*, czyli tworzenia instancji modułów. Problem ten został szczegółowo przeanalizowany w [[cite:Gasbichler2006]], skutkując stworzeniem notacji /interfejsów modułów/ ułatwiającej automatyczną rezolucję zależności. Rozwiązanie to jest dalekie od doskonałego, toteż język =FOOF= stosuje inne podejście opisane w sekcji [[ref:sec:knowledge-engineering]].

** Inżynieria wiedzy w języku
#+LaTeX: \label{set:knowledge-engineering}

Ostatnią i zarazem najbardziej zaawansowaną funkcjonalnością języka =FOOF= jest jego wsparcie dla inżynierii wiedzy (ang. /knowledge engineering/), objawiające się umożliwieniem refleksji na podstawie pewnych /informacji/, które zostały odkryte podczas działania programów. Wspomniane, powiązane ze sobą logicznie informacje, czyli *wiedza*, mogą dotyczyć wielu różnych aspektów działania aplikacji i są w dużej mierze uzależnione od domeny rozwiązywanych problemów.

Istnieje wiele metod reprezentacji i przetwarzania wiedzy, które różnią się sposobem dostępu do zdobytych informacji, a co za tym idzie, stosownością do rozwiązywania danych klas problemów [[cite:Wang2013]]. Dlatego też, wybór konkretnej reprezentacji i mechanizmu przetwarzania wiedzy w języku =FOOF= uzależniony jest od pragmatycznego jego zastosowania.

Wiodącym zadaniem inżynierii wiedzy w języku =FOOF= jest realizacja jednego z główych założeń języka, czyli osiągnięcia *świadomości platformy* poprzez zdobycie i udostępnienie wiedzy o platformie sprzętowej i samej aplikacji na niej działającej. Wiedza ta ma stanowić bazę do podejmowania decyzji o rozwoju obliczeń prowadzonych w aplikacji, a także o samej strukturze systemu.

W założeniu ma to umożliwić automatyczną konfigurację i ewolucję rozproszonych aplikacji zbudowanych z wykorzystaniem języka =FOOF=. Na przykład, system inteligentnego domu, po wykryciu podłączenia w odpowiednim pomieszczeniu czujnika temperatury o wyższej dokładności pomiarów niż dotychczasowo dostępna, powinien bez modyfikacji programu, ani ingerencji jego użytkownika, zacząć z niego korzystać. Natomiast, w przypadku katastrofalnego błędu rzeczonego czujnika, system powinien wrócić do korzystania z poprzedniego czujnika.

Literatura związana z tą dziedziną nauki, która zarazem dotyczy systemów rozproszonych o wysokiej heterogeniczności, takich jak Internet Rzeczy, bardzo często wykorzystuje podejście ontologiczne [[cite:Hachem2011, Wang2013, Samimi2014]]. Polega ono na budowie ontologii domenowej na potrzeby systemu, gdzie wiedza jest reprezentowana jako instancje i klasy obiektów powiązanych ze sobią pewnymi zależnościami. Ontologia ta może być następnie odpytywana, a działający w niej algorytm rozumowania (ang. /reasoner/) pozwala odkrywać nowe zależności pomiędzy obiektami.

Rozwiązane to wchodzi w konflikt z założeniami języka =FOOF= przez swoje skomplikowanie, relatywną restrykcyjność i statyczność bazy wiedzy oraz kosztowność obliczeniową, toteż, pomimo niewątpliwych zalet, nie mogło zostać wdrożone. Alternatywnym rozwiązaniem zastosowanym w języku jest podejście regułowe, polegające na reprezentacji wiedzy w formie *faktów* o nienarzuconej strukturze i przetwarzaniu tej wiedzy za pomocą *reguł* weryfikujących ową strukturę. Listing [[ref:code:ex-rbs-usage]] pokazuje podstawowe operacje związane z inżynierią wiedzy dostępne w języku =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania prymitywnych operacji bazy wiedzy w języku.}}
#+latex: \label{code:ex-rbs-usage}
#+begin_src scheme
(whenever set-of-conditions
  (lambda (_)
    (retract! some-fact)
    (assert! another-fact)))
(signal! an-event)
#+end_src
#+latex: \end{listing}

Przykład ten definiuje jedną regułę bez zagłębiania się w szczegóły implementacji systemu regułowego języka =FOOF=. Reguła ta, bazując na spełnialności pewnego zbioru warunków =set-of-conditions= modyfikuje wbudowaną bazę faktów przez *asercję* i *retrakcję* rożnych faktów. Dodatkowo, przykład *sygnalizuje* zaistnienie pewnego zdarzenia =an-event=, co konceptualnie jest tożsame z asercją i późniejszą retrakcją faktu opisującego zajście tego zdarzenia w systemie.

Projekt przewiduje wykorzystanie opisanych powyżej podstawowych operacji oraz wiedzy możliwej do zdobycia podczas kompilacji programów języka =FOOF= poprzez *inferencję* faktów dotyczących struktury ich kodu źródłowego, do rozwiązania opisanego w sekcji [[ref:sec:module-system]] problemu linkowania modułów. Rozwiązanie to polega na przetworzaniu inferowanej wiedzy za pomocą zbioru reguł, zwanych kolektywnie *protokołem modułu*, w celu rezolucji zależności je spełniających w sposób automatyczny. Moduły, zamiast dokładnego sprecyzowania swoich zależności, mogą podać protokóły, które są konieczne i wystarczające do poprawnego, wspólnego działania, a system regułowy automatycznie wybierze spełniające je, dostępne submoduły.

* Kompilator języka =FOOF=
Niniejszy rozdział przedstawia implementację kompilatora języka programowania =FOOF= szczegółowo opisując jego architekturę i poszczególne fazy kompilacji programów.

Kompilator jest programem komputerowym, którego głównym zadaniem jest *transformacja kodu źródłowego* programów do formatu bardziej odpowiedniego do uruchomienia przez maszynę [[cite:Aho2006]]. Wynikiem działania kompilatora jest najczęściej plik wykonywalny zawierający instrukcje możliwe do uruchomienia przez procesor lub /maszynę wirtualną/, w przypadku kompilatorów /kodu bajtowego/. Kompilacja jest zwykle podzielona na kilka osobnych faz, takich jak analiza leksykalna, analiza semantyczna, optymalizacja i generacja kodu, które różnią się typem i celem przeprowadzanych transformacji [[cite:Aho2006]].

Kompilator języka =FOOF= jest w założeniu kompilatorem /kodu maszynowego/, wynikiem działania którego jest strumień instrukcji możliwych do uruchomienia przez procesor komputera. Niestety, w wyniku ograniczeń czasowych i samej wielkości takiego projektu, ostatnie fazy kompilacji odpowiedzialne za generację kodu maszynowego zostały pominięte, a kompilacja programów kończy się na uruchamialnej reprezentacji pośredniej programów.

Towarzyszący pracy program został napisany w sposób inkrementalny [[cite:Ghuloum2006]] z wykorzystaniem wspólnego podzbioru języków Scheme oraz =FOOF=, celem późniejszego osiągnięcia auto-kompilacji (ang. /bootstrapping compiler/). Podczas tworzenia kompilatora nieocenione okazały się wskazówki na temat implementacji /języków funkcyjnych/, do których należy również język =FOOF=, przedstawione w [[cite:PeytonJones1992]].

** Architektura kompilatora
Architektura kompilatora języka =FOOF= jest typowa dla tego typu programów [[cite:Aho2006]], kompilacja została podzielona na jeden przebieg, na który składa się kilka logicznie po sobie następujących faz. Schemat [[ref:fig:compilation-phases]] prezentuje obecnie zaimplementowane w kompilatorze fazy oraz te, których implementacja została przewidziana w przyszłości, wraz z przykładami pośrednich reprezentacji programów w nich występujących.

#+begin_center
#+label: fig:compilation-phases
#+caption: Schemat poszczególnych faz kompilacji i przykładowych danych będących wynikiem ich działania.
#+attr_latex: :width 1.0\textwidth :placement [H]
[[file:./img/compilationphases.pdf]]
#+end_center

Pierwszą fazą jest faza *analizy leksykalnej i syntaktycznej* polegająca na transformacji kodu źródłowego - tekstu enkodującego programy - do formatu wewnętrznego możliwego do przetworzenia przez następne fazy kompilacji. Analiza syntaktyczna wykorzystuje opisaną w rozdziale [[ref:sec:lang-description]] homoikoniczność języka =FOOF= i reprezentuje programy jako drzewa zbudowane z podstawowych typów danych dostarczanych przez język.

Druga faza kompilacji to faza *makroekspansji* polegająca na uproszczeniu konstrukcji syntaktycznych występujących w programach za pomocą szeregu transformacji. Faza ta pozwala uprościć analizę semantyczną pojawiającą się w późniejszych fazach kompilacji dzięki redukcji liczby różnych konstrukcji języka, które muszą być brane pod uwagę.

Trzecią fazą jest faza *konwersji /Continuation Passing Style/* polegająca na syntaktycznej transformacji kodu źródłowego programów celem wplecenia do niego *kontynuacji* [[cite:Appel1992]]. Reprezentacja pośrednia programów po tej fazie kompilacji różni się zasadniczo od dotychczasowej reprezentacji, dzięki czemu ułatwia implementację szeregu opisanych wcześniej funkcjonalności języka.

Ostatnie dwie fazy kompilacji, czyli fazy *optymalizacji* i *generacji kodu maszynowego* w dużej mierze polegają na uproszczeniu przetworzonego kodu programów i przetłumaczeniu go na strumień prostych instrukcji możliwych do uruchomienia przez procesor komputera.

Kompilator działa w pojedynczym przebiegu, podczas którego każda z faz jest uruchamiana dokładnie jeden raz. Szczegółowy opis działania i implementacji poszczególnych faz został zawarty w dalszej części rozdziału.

** Parsowanie
Pierwszym logicznym elementem kompilatora jest *parser* przeprowadzający analizę leksykalną i syntaktyczną. Jego zadaniem jest transformacja tekstu reprezentującego programy języka =FOOF= do drzewiastej reprezentacji bazującej na podstawowych typach danych udostępnianych przez język.

W związku z wyborem technologii wykorzystanych do implementacji kompilatora, budowa parsera przez niego używanego została oparta o, będące częścią standardu języka Scheme, podstawowe funkcje operujące na plikach i kodzie źródłowym, takie jak =with-input-from-file= oraz =read= [[cite:Sperber2010]]. Implementacja dedykowanych parserów jest żmudna i nie prezentuje zbyt wysokiej wartości poznawczej, natomiast tworzenie generatora parserów, pomimo niewątpliwej ciekawości i przydatności z punktu widzenia użyteczności języka programowania, nie stanowi tematu niniejszej pracy. Powstała implementacja jest więc minimalną wersją niezbędną do umożliwienia dalszej kompilacji programów.

Opisany parser wspiera podstawową składnię języka =FOOF= wynikającą z jego homoikoniczności oraz jedno rozszerzenie składniowe usprawniające generowanie programów wewnątrz kompilatora. Rozszerzenie to polega na transformacji kombinacji znaków specjalnych \texttt{'}, =`=, \texttt{,} oraz \texttt{,@} do odpowiadających im konstrukcji w formacie S-wyrażeń. Listing [[ref:code:ex-syntax-expansion]] pokazuje kod źródłowy i kod powstały po ekspansji syntaktycznej przeprowadzonej przez parser.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Obsługa rozszerzeń składniowych S-wyrażeń w języku \texttt{FOOF}.}}
#+latex: \label{code:ex-syntax-expansion}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Kod źródłowy:
'(some value)
`(a ,b ,@c)
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Po ekspansji:
(quote (some value))
(quasiquote (a (unquote b)
               (unquote-splicing c)))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Należy zauważyć, że ekspansja syntaktyczna powyższego rozszerzenia składniowego nie jest jednoznacza z ekspansją wynikającą z jego znaczenia, która jest przeprowadzana w fazie makroekspansji opisanej w sekcji [[ref:sec:macroexpansion-impl]].

Naturalnie, istnieje możliwość łatwej wymiany implementacji parsera w przyszłości na mechanizm bardziej rozbudowany, wspierający dowolną ilość rozszerzeń składniowych. Można do tego celu wykorzystać generator parserów zbudowany w oparciu o gramatyki PEG (ang. /Parsing Expression Grammars/) [[cite:Ford2004]] oraz monadyczne kombinatory parserów [[cite:Hutton1996]], które szczególnie dobrze nadają się do budowy parserów dla języków o nieskomplikowanej podstawowej gramatyce, takich jak =FOOF=.

** Makroekspansja
#+LaTeX: \label{sec:macroexpansion-impl}

Pierwszą fazą transformującą w znaczący sposob kod źródłowy języka =FOOF=, jest faza makroekspansji. Jej głównym zadaniem jest umożliwienie istnienia opisanego w rozdziale [[ref:sec:lang-description]] systemu makr, a polega ona na aplikacji definicji makr do fragmentów kodu źródłowego znajdujących się w miejscu ich wywołań. Listing [[ref:code:macro-expansion-pseudocode]] prezentuje pseudokod algorytmu realizującego fazę makroekspansji w notacji języka =FOOF=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Pseudokod algorytmu makroekspansji w notacji języka \texttt{FOOF}.}}
#+latex: \label{code:macro-expansion-pseudocode}
#+begin_src scheme
(define (macroexpand expression defined-macros)
  (if (and (list? expression)
           (not (quote? expression)))
      (if (macro-defined? (macro-name expression) macros)
          (macroexpand (apply-expander (macro-name expression)
                                       defined-macros
                                       expression)
                       defined-macros)
          (map (lambda (subexpression)
                 (macroexpand subexpression macros))
               expression))
      expression))
#+end_src
#+latex: \end{listing}

Algorytm ten jest rekurencyjny i przebiega w następujący sposób:

- Jeśli wyrażenie jest listą, której pierwszy element jest nazwą zdefiniowanego uprzednio makra, to następuje makroekspansja wyrażenia otrzymanego przez aplikację definicji makra do owego wyrażenia.

- Jeśli wyrażenie jest listą, ale jej pierwzy element nie identyfikuje zdefiniowanego uprzednio makra, to następuje makroekspansja każdego podwyrażenia wchodzącego w skład tego wyrażenia.

- Jeśli wyrażenie nie jest listą to zostaje zwrócone bez zmian.

Powyższy algortym uwzględnia możliwość, w której analizowanym wyrażeniem jest specjalna formuła =(quote ...)= przerywająca makroekspansję. Podobnie jak w przypadku wyrażeń nie będących listami, formuła =(quote ...)= zostaje zwrócona bez zmian. Algorytm uwzględnia również sytuację, w której wynikiem ekspansji jednego makra jest wywołanie innego makra, dzięki rekurencyjnemu wywołaniu makroekspansji po aplikacji definicji makra. Sytuację tę obrazuje listing [[ref:code:ex-macro-expansion-steps]].

W przykładzie została wykorzystana konstrukcja =let*=, która semantycznie oznacza zagnieżdżoną deklarację zmiennych lokalnych =a= oraz =b=. Makro odpowiedzialne za ekspansję konstrukcji =let*= skutkuje wygenerowaniem dwóch wywołań makra =let=, które następnie jest zamieniane na wywołania funkcji anonimowych (tworzonych za pomocą konstrukcji =lambda=) z odpowiednimi parametrami.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład działania algorytmu makroekspansji.}}
#+latex: \label{code:ex-macro-expansion-steps}
#+begin_src scheme
;; Kod źródłowy:
(let* ((a 23)
       (b (+ a 5)))
  (* 2 b))

;; Pierwszy krok makroekspansji:
(let ((a 23))
  (let ((b (+ a 5)))
    (* 2 b)))

;; Drugi krok makroekspansji:
((lambda (a)
   (let ((b (+ a 5)))
     (* 2 b)))
 23)

;; Trzeci krok makroekspansji:
((lambda (a)
   ((lambda (b)
      (* 2 b))
    (+ a 5)))
 23)
#+end_src
#+latex: \end{listing}

Obecna implementacja nie wspiera definiowania nowych makr przez użytkowników języka =FOOF=. Powodem tej niedogodności jest nietrywialna interakcja systemu makr i systemu modułów zastosowanego w języku, która została szczegółowo przeanalizowana w [[cite:Gasbichler2006]]. System makr do poprawnego funkcjonowania wymaga znajomości definicji makr, które znajdują się w różnych modułach, przed uruchomieniem programu, natomiast system modułowy wymaga uruchomienia programu w celu przeprowadzenia linkowania modułów. Rozwiązanie tego problemu jest nietrywialne, w związku z czym nie zostało uwzględnione w projekcie języka. Lista predefiniowanych makr dostępnych w języku =FOOF= została zawarta w dodatku [[ref:sec:built-ins]].

Innym problemem manifestującym się w wielu systemach makr jest opisany w sekcji [[ref:sec:macros-description]] problem higieniczności, polegający na nieoczekiwanej injekcji nieprawidłowych wartości do kodu generowanego przez makra. W zwązku z opisaną powyżej niedogodnością, problem ten nie jest obecny w implementacji języka =FOOF= i jego rozwiązanie stanowi problem otwarty. Znanych jest kilka sposobów rozwiązania problemu higieniczności systemu makr, na przykład wykorzystanie specjalnego systemu typów [[cite:Bawden2000]], lub wieży refleksji makroekspansji [[cite:Queinnec1996]].

** Obsługa systemu modułowego
Implementacja systemu modułowego języka =FOOF= wymaga niewielkiego wsparcia, w chwili obecnej, ze strony kompilatora.

Możliwość definiowania modułów została zreazilowana z wykorzystaniem systemu makr jako wywołania makr =structure= oraz =module= odpowiadające odpowiednio strukturom i funktorom opisanym w sekcji [[ref:sec:module-system]]. Makra te generują wywołania specjalnej funkcji =&make-structure= budującej struktury z prostych wartości. Listing [[ref:code:ex-module-expansion]] prezentuje wynik makroekspansji makra =module=, której pośrednim krokiem jest ekspansja makra =structure=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ekspansji makra \texttt{module}.}}
#+latex: \label{code:ex-module-expansion}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Kod źródłowy:
(module (X a b)
  (define (foo x)
    ...)
  (define (bar y)
    ...))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Po makroekspansji:
(define (X a b)
  (letrec ((foo (lambda (x)
                  ...))
           (bar (lambda (y)
                  ...)))
    (&make-structure
     'foo foo
     'bar bar)))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Definicje należące do zdefiniowanego modułu =X= transformowane są do postaci wzajemnie rekurencyjnej za sprawą konstrukcji =letrec=, a następnie ich wartości łączone są w jeden obiekt struktury. Do definicji należących do tak otrzymanej wartości można odnosić się z wykorzystaniem specjalnej składni =module.member=, która została zrealizowana jako ekspansja symboli w fastępnej fazie kompilacji opisanej w sekcji [[ref:sec:cps-impl]]. Wywołanie funkcji =bar= instancji =x= modułu =X= wygląda więc następująco: =(x.bar 23)=.

** Transformacja /Continuation Passing Style/
#+LaTeX: \label{sec:cps-impl}

Kolejną fazą kompilacji jest faza konwersji przekazywania kontynuacji (ang. /Continuation Passing Style/, /CPS/) polegająca na automatycznej transformacji kodu źródłowego programu do formatu, w którym wszystkie funkcje przyjmują dodatkowy argument będący sukcesywnie przekazywaną dalej kontynuacją [[cite:Appel1992]].

Celem tej fazy jest wplecenie notacji kontynuacji opisanych w sekcji [[ref:sec:continuations-description]] do pośredniej reprezentacji programów. Listing [[ref:code:ex-cps-principle]] prezentuje przykład konwersji CPS prostej funkcji.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład konwersji \textit{Continuation Passing Style}.}}
#+latex: \label{code:ex-cps-principle}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Styl bespośredni:
(lambda (x y)
  (* 2 (+ x y)))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Styl Continuation Passing:
(lambda (x y cont)
  (__+ x y
       (lambda (v)
         (__* 2 v cont))))

;; Konwersja wbudowanych funkcji:
(define (__+ a b cont)
  (cont (+ a b)))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Po transformacji, funkcja ta przyjmuje dodatkowy argument =cont=, który następnie przekazuje dalej w ciągu obliczeń. Analogicznie, wbudowane funkcje dodawania =+= i mnożenia =*= również przyjmują dodatkowy argument, który wywołują z wynikiem odpowiedniej operacji, powodując aplikację kontynuacji.

W przykładzie można zauważyć doprecyzowanie kolejności wykonywania działań po transformacji CPS - pierwszą wykonaną operacją jest dodawanie, a jego wynik przekazywany jest do, specjalnie w tym celu stworzonej, kontynuacji pośredniej i następnie od operacji mnożenia wraz z kontynuacją =cont= wywołania funkcji.

Algorytm automatycznej konwersji CPS polega na analizie struktury kodu źródłowego metodą /dziel i zwyciężaj/ i przeprowadzeniu serii prostych podstawień, z których najważniejsze to:

- Transformacja identyfikatorów przebiega przez dodanie prefixu =__= i unormowanie znaków specjalnych w celu wyraźnego odseparowania wartości przed i po konwersji.

- Transformacja wartości prostych polega na wywołaniu /aktualnej kontynuacji/ z ich wartością.

- Transformacja funkcji polega na rozszerzeniu listy ich argumentów o dodatkowy argument reprezentujący /kontynuację wywołania funkcji/ i rekurencyjnym przeprowadzeniu transformacji ciała funkcji przy jednoczesnej podmianie aktualnej kontynuacji na wprowadzoną uprzednio kontynuację wywołania funkcji.

Dokłady opis algorytmu konwersji /Continuation Passing Style/ zawarto w [[cite:Appel1992]]. Ponieważ konwersja CPS ma miejsce podczas kompilacji i przed uruchomieniem programu, toteż wartość /aktualnej kontynuacji/ nie jest ustalona. W związku z tym, powyższy *algorytm generuje kod*, który będzie się składał na faktyczną wartość aktualnej podczas uruchomienia programu kontynuacji.

Jedną z cech konwersji CPS jest dokładne sprecyzowanie kolejności zachodzenia operacji w transfomowanych programach, co uwydatnia problem implementacji rekurencji. Zgodnie z opisem problemu z sekcji [[ref:sec:continuations-description]], funkcje rekurencyjne (a także funkcje wzajemnie-rekurencyjne) wymagają istnienia własnej (pośrednio w przypadku funkcji wzajemnie-rekurencyjnych) wartości zanim będą mogły zostać zbudowane, co prowadzi do powstania sprzeczności. Nie jest to jednak do końca prawdziwe stwierdzenie, otóż funkcje rekurencyjne wymagają pewnej *lokacji*, w której znajdzie się ich wartość, podczas budowy tejże wartości, dzięki czemu ich implementacja jest możliwa. Listing [[ref:code:cps-letrec]] prezentuje wynik transformacji CPS konstrukcji =letrec= służącej do definiowania wzajemnie-rekurencyjnych funkcji.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład transformacji konstrukcji \textt{letrec}.}}
#+latex: \label{code:cps-letrec}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
(letrec ((even? (lambda (x)
                  ...
                  odd?
                  ...))
         (odd? (lambda (x)
                 ...
                 even?
                 ...)))
  (even? 7))
#+end_src
#+LaTeX: \columnbreak
#+BEGIN_SRC scheme
(let ((__even? nil)
      (__odd? nil))
  (set! __even? (lambda (x)
                  ...
                  __odd?
                  ...))
  (set! __odd? (lambda (x)
                 ...
                 __even?
                 ...))
  (__even? 7
           (lambda (value)
             value)))
#+END_SRC
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Transformacja CPS w tym przypadku umożliwia implementację funkcji rekurencyjnych tworząc dla ich wartości lokacje (=__even?= oraz =__odd?=), do których następnie wpisuje za pomocą konstrukcji =set!= zbudowane wartości. W efekcie, obie funkcje mają wszystkie niezbędne informacje i mogą korzystać z pozostałych funkcji wprowadzonych przez konstrukcję =letrec=. Rozwiązanie to jest analogiczne do techniki opisanej w [[cite:German1995]] oraz stanowi preferowalną (pod warunkiem dopuszczenia istnienia mutacji w języku) alternatywę dla wykorzystania kombinatora =Y= [[cite:Felleisen1991]], którego implementacja dla funkcji wzajemnie-rekurencyjnych jest nietrywialna. Innym podejściem do rozwiązania problemu rekurencji jest automatyczna eliminacja wzajemnej rekursji [[cite:Kaser1993]].

Warto zauważyć, iż proste modyfikacje podstawowego algorytmu konwersji /Continuation Passing Style/, polegające na generowaniu wywołań wbudowanych funkcji w stategicznych miejscach, mogą pomóc w implementacji szerokiej gamy mechanizmów kontroli przepływu sterowania, jakich jaki obsługa błędów oraz multiprocessing. Fakt ten został wdrożony do implementacji kompilatora języka =FOOF= i szczegółowo opisany w rozdziale [[ref:sec:runtime-system]].

** Optymalizacja i generacja kodu
Ostatnie dwie fazy kompilacji to optymalizacja i generacja kodu wynikowego. Zadaniem tych faz jest uproszczenie, przyspieszenie i przygotowanie przetransformowanego w poprzednich fazach kodu do postaci możliwej do uruchomienia przez komputer.

Fazy te zostały niestety pominięte w związku z ich skomplikowaniem i ograniczeniami czasowymi nałożonymi na projekt. W chwili obecnej, kompilator języka =FOOF= kończy działanie produkując kod pośredni, będący uruchamialnym podzbiorem języków Scheme i =FOOF=, dzięki czemu może zostać uruchomiony przez interpretery i kompilatory tych języków.

W przyszłości istnieje możliwość relatywnie łatwego dodania pozostałych faz kompilacji. W szczególności, zaimplementowana już faza konwersji /Continuation Passing Style/ opisana w sekcji [[ref:sec:cps-impl]] ułatwia implementację szerokiej gamy ciekawych optymalizacji, takich jak częściowa ewaluacja statycznych wartości (ang. /partial evaluation/), prowadząca do zwijania wartości stałych (ang. /constant folding/), oraz eliminacji jednakowych podwyrażeń (ang. /common subexpression elimination/) [[cite:Bacon2002]].

Implementacja fazy generacji kodu maszynowego wymagać będzie dodatkowo *konwersji domknięć leksykalnych* (ang. /closure conversion/) i opcjonalnie *lambda-unoszenia* (ang. /lambda lifting/) [[cite:PeytonJones1992]], których zadaniem jest przeniesienie definicji funkcji anonimowych wygenerowanego kodu do globalnej przestrzeni nazw. Listing [[ref:code:lambda-lift-vs-closure-conv]] ilustruje działanie obu tych transformacji.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ilustrujący różnice pomiędzy algorytmami lambda-unoszenia oraz konwersji domknięć leksykalnych.}}
#+latex: \label{code:lambda-lift-vs-closure-conv}
#+begin_src scheme
;; Oryginalny kod źródłowy:
(let* ((x 23)
       (plus-x (lambda (n)
                (+ n x))))
  (plus-x 5))
#+end_src
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Lambda-unoszenie:
(define (plus-x x n)
  (+ n x))

(let* ((x 23))
  (plus-x x 5))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Konwersja domknięć-leksykalnych:
(define __lambda0 (self n)
  (+ n (&value-of self 'x)))

(let* ((x 23)
       (plus-x (&closure __lambda0
                        'x x)))
  (&apply plus-x 5))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Konwersja domknięć leksykalnych polega na przeniesieniu definicji funkcji anonimowych do globalnej przestrzeni nazw oraz odpowiedniej modyfikacji miejsc tworzenia domknięć leksykalnych. Technika lambda-unoszenia, która zwykle jest wykonywana tuż po konwersji domknięć leksykalnych, polega na redukcji ilości stworzonych obiektów funkcyjnych przez promocję zmiennych wolnych domknięć leksykalnych do listy argumentów funkcji i modyfikacji miejsc wywołań funkcji w celu przekazania dodatkowych wartości. Technika ta pozwala ominać proces budowania domknięcia leksykalnego i jednocześnie przyspieszyć miejsca jego wywołań.

* Środowisko uruchomieniowe języka
#+LaTeX: \label{sec:runtime-system}

Niniejszy rozdział przedstawia architekturę środowiska uruchomieniowego (ang. /runtime system/) języka =FOOF=, czyli środowiska zawierającego procedury niezbędne do uruchamiania programów napisanych w tym języku. Do procedur takich należą te odpowiedzialne za budowę podstawowych typów danych dostarczanych przez język programowania, procedury zarządzania pamiecią programów, a także te niezbędne do działania zaawansowanych funkcjonalności języka.

W związku ze zróżnicowaniem funkcjonalności dostępnych w różnych językach programowania, nie istnieje jedna kanoniczna metoda implementacji ich środowisk uruchomieniowych. Sytuacja jest wręcz przeciwna, dwie różne implementacje tego samego języka programowania mogą posiadać zupełnie odmienne środowiska uruchomieniowe, natomiast dwa zupełnie różne języki mogą korzystać z tego samego środowiska uruchomieniowego, co często ma miejsce w przypadku /maszyn wirtualnych/. Przykładem takiej sytuacji jest wykorzystanie maszyny wirtualnej BEAM [[cite:Armstrong1996]], oryginalnie zaprojektowanej dla języka Erlang, przez kilka innych języków programowania, takich jak Elixir i Joxa.

Język =FOOF= korzysta w obecnej postaci ze środowiska uruchomieniowego języka Scheme, rozszerzając jego funkcjonalność o mechanizmy niezbędne do implementacji przetwarzania współbieżnego, zaawansowanej obsługi błędów, a także zapewnienia wsparcia dla inżynierii wiedzy.

** Architektura środowiska uruchomieniowego
Architektura środowiska uruchomieniowego wykorzystanego w implementacji języka =FOOF= jest relatywnie nieskomplikowa i składa się z niewielkiej liczby logicznych elementów. Po części jest to zasługa wiernego podążania za zasadami projektowania języków programowania przedstawionymi w [[cite:Hoare1973]] oraz wykorzystania środowiska uruchomieniowego języka Scheme. Diagram poszczególnych elementów logicznych i ich wzajemnej interakcji został zawarty na schemacie [[ref:fig:rt-architecture]].

#+begin_center
#+label: fig:rt-architecture
#+caption: Schemat architektury środowiska uruchomieniowego języka =FOOF=.
#+attr_latex: :width 0.6\textwidth :placement [H]
[[file:./img/rtarchitecture.pdf]]
#+end_center

Konceptualnie, pamięć dostępna dla środowiska uruchomieniowego języka =FOOF= została podzielona na dwa segmenty. Pierwszy z nich, oznaczony na diagramie kolorem niebieskim, zawiera jedynie struktury danych wykorzystywane przez środowisko uruchomieniowe, takie jak kolejka i deskryptory procesów działających w systemie, czy dane systemu uruchomieniowego języka Scheme. Drugi segment pamięci, oznaczony na diagramie kolorem żółtym, stanowi pamięć operacyjna, czyli pamięć przeznaczona i dostępna dla uruchamianych programów.

Segment pamięci operacyjnej został dodatkowo podzielony na trzy obszary, dwa z których zostały zarezerwowane na obsługę implementacji systemu regułowego do przechowywania baz faktów oraz reguł (rozdział [[ref:sec:knowledge-engineering]]), a trzeci, największy z nich, stanowi główny obszar, w którym przechowywane są obiekty reprezentujące wbudowane typy danych.

Główny obszar pamięci operacyjnej programów jest wspólny dla wszystkich procesów działających w systemie (symbolizowanych na diagramie przez bloki =μProcN=), dzięki czemu możliwe jest uniknięcie nadmiernego kopiowania danych podczas przesyłania wiadomości pomiędzy procesami kosztem synchronizacji dostępu do pamięci. Podejście to, zwane *stertą współdzieloną*, jest alternatywą do podejścia zastosowanego w implementacji języka Erlang, gdzie każdy proces działa w osobnej puli pamięci, przez co wymagane jest, często kosztowne, kopiowanie struktury wiadomości [[cite:Armstrong1996]].

Obecna implementacja, w związku z ograniczeniami czasowymi narzuconymi na projekt, nie wykorzystuje pełnego potencjału przedstawionej architektury, ponieważ działa /jednowątkowo/, czyli jest ograniczona tylko do jednego wątku systemu operacyjnego. Nie ma to jednak wpływu na współbieżność procesów języka =FOOF= działających w środowisku uruchomieniowym, co zostało poruszone w sekcji [[ref:sec:cfs-impl]].

W przyszłości istnieje możliwość rozwinięcia implementacji w celu wsparcia wielowątkowości, na przykład poprzez wykorzystanie *barier pamięci*, *operacji atomowych* oraz *pamięci lokalnej dla wątku* (ang. /thread-local storage/), co pozwoli osiągnąć przyspieszenie aplikacji języka =FOOF=.

** Implementacja podstawowych typów danych
Wybór sposóbu reprezentacji podstawowych typów danych w językach programowania jest bardzo ważny i często stanowi pole do czynienia kompromisów i optymalizacji [[cite:Aho2006]]. Języki funkcyjne, do których należy język =FOOF=, z racji swojego nacisku na przejrzystą semantykę charakteryzują się relatywną prostotą reprezentacji wbudowanych typów danych [[cite:PeytonJones1992]]. Schemat [[ref:fig:object-representation]] prezentuje przykład reprezentacji typów danych wprowadzony w [[cite:Gudeman1993]] na potrzeby języków /dynamicznie typowanych/, czyli nie weryfikujących typów zmiennych podczas kompilacji.

#+begin_center
#+label: fig:object-representation
#+caption: Schemat przykładowej reprezentacji typów danych języków funkcyjnych.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/objectrepr.pdf]]
#+end_center

Reprezentacja ta przewiduje istnienie dwóch klas obiektów:

- *prostych* - reprezentowanych przez jedno słowo procesora i posiadających krótki, trzybitowy tag określający ich dokładny typ,

-  *złożonych* - reprezentowanych przez kilka kolejnych słów procesora, z których pierwsze zawiera nieco dłuższy, ośmiobitowy tag określający ich dokłady typ oraz pewien zestaw metadanych do wykorzystania przez środowisko uruchomieniowe, a następne są obiektami prostymi.

Reprezentacja taka pozwala w łatwy sposób enkodować wszystkie podstawowe typy danych języka =FOOF=. Na przykład, listy pojedynczo-wiązane mogą być zrealizowane jako ciąg par reprezentowanych przez obiekty złożone składające się z dwóch obiektów prostych - wskaźników wskazujących na inne obiekty złożone będące elementami pary. Integracja ze środowiskiem uruchomieniowym języka Scheme pozwoliła pominąć żmudną implementację reprezentacji i procedur konstrukcji wbudowanych typów danych języka. Ich semantyka jest więc zgodna z opisem zawartym w [[cite:Sperber2010]], a ekwiwalencję składniową zaprezentowano na listingu [[ref:code:datatype-equivalence]].

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Porównanie wbudowanych typów danych języka \texttt{FOOF} i dialektu języka Scheme o nazwie Racket.}}
#+latex: \label{code:datatype-equivalence}
#+LaTeX: \begin{multicols}{2}
#+begin_src clojure
; Język FOOF:
23.5
symbol
:symbol
"ciąg znaków"
(1 2 3)
[1 2 3]
{:a 1 :b 2}
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Język Racket:
23.5
symbol
:symbol
"ciąg znaków"
(1 2 3)
#(1 2 3)
#hash((:a . 1) (:b . 2))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Wszystkie podstawowe typy danych języka =FOOF= mają swoje dokładne, semantyczne odpowiedniki w języku Scheme, a odróżnia je jedynie reprezentacja literałowa. Warto zauważyć, iż zależość ta jest prawdziwa także dla bardziej złożonych typów danych, jak funkcje, które są kodowane w ten sam sposób. Oba środowiska uruchomieniowe różną się natomiast reprezentacją kontynuacji - język =FOOF= używa konwersji przekazywania kontynuacji i reprezentuje je jako zwykłe funkcje - oraz brakiem idei procesów w standardzie języka Scheme.

** Implementacja kontynuacji
Implementacja kontynuacji w języku =FOOF= została zrealizowana już podczas kompilacji za sprawą automatycznej konwersji /Continuation Passing Style/, która została szczegółowo opisana w sekcji [[ref:sec:cps-impl]].

Implementacja ta pozwala reprezentować kontynuacje za pomocą zwykłych funkcji, ale w celu ułatwienia implementacji pozostałych mechanizmów kontroli przepływu sterowania, wymaga uwzględnienia pewnej modyfikacji. Modyfikacją tą jest wykorzystanie techniki *tampoliny*, polegającej na zwracaniu następnego kroku kontynuacji jako wyniku obecnego kroku zamiast bezpośredniego wywołania dalszej części kontynuacji [[cite:Appel1992]].

Technika ta pozwala przerwać działanie kontynuacji pomiędzy poszczególnymi jej krokami przez zwyczajne nie-wywoływanie następnego kroku, a do jej implementacji wymagana jest jedynie modyfikacja kodu pośredniego programów w miejscach, w których normalnie następowałaby aplikacja następnej części kontynuacji. Listing [[ref:code:ex-cps-execution]] pokazuje efekt zastosowanej modyfikacji algorytmu konwersji CPS oraz wyników uruchomienia poszczególnych kroków kontynuacji.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład uruchomienia funkcji z listing \ref{code:ex-cps-principle}.}}
#+latex: \label{code:ex-cps-execution}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Konwersja wbudowanych funkcji:
(define (__+ a b cont)
  (&yield-cont cont (+ a b)))

;; Przykładowe wyrażenie:
((lambda (x y cont)
   (__+ x y
        (lambda (v)
          (__* 2 v cont))))
 23
 5
 identity)
#+END_SRC
#+LaTeX: \columnbreak
#+BEGIN_SRC scheme
;; Po pierwszym kroku:
(&yield-cont (lambda (v)
               (__* 2 v cont))
             (+ 23 5))

;; Po drugim kroku:
(&yield-cont cont
             (* 2 28))

;; Po trzecim kroku:
56
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

Przykład pokazuje, iż jedyną wymaganą modyfikacją jest emitowanie wywołań wbudowanej funkcji =&yield-cont= w miejscach bezpośredniego wywołania następnej kontynuacji. Funkcja =&yield-cont= zwyczajnie zwraca następny krok kontynuacji wraz z wartością, która ma do niego trafić - tak zwaną *dziurą kontynuacji*. W celu kompletnego uruchomienia kontynuacji należy sukcesywnie aplikować zwracaną funkcję do zwracanej wartości.

Wykorzystanie techniki trampoliny prowadzi do powstania /punktów sekwencyjnych/ w programie, czyli zaistnienia miejsc, w których *gwarantowane* jest wykonanie dotychczasowych obliczeń (w szczególności /efektów/ takich jak mutacja wartości). Miejsca te są analogiczne do punktów sekwencyjnych obecnych w interpreterach kodu bajtowego oraz interpreterach redukcyjnych [[cite:PeytonJones1992]], i mogą z powodzeniem służyć do realizowania podobnych funkcji - na przykład /debugowania/, lub /wywłaszczania/. Zostało to opisane w sekcji [[ref:sec:cfs-impl]].

** Implementacja obsługi błędów
Środowisko uruchomieniowe języka =FOOF= pozwala zrealizować obecny w języku zaawansowany mechanizm obsługi błędów i sytuacji wyjątkowych. Mechanizm ten został zaimplementowany w oparciu o kontynuacje i korzysta z dwóch funkcji wbudowanych dostarczanych przez środowisko uruchomieniowe.

Funkcje te, =&uproc-error-handler= oraz =&set-uproc-error-handler!= są odpowiedzialne za zarządzanie aktualnie aktywną procedurą obsługi sytuacji wyjątkowej, a ich wywołania są emitowane w fazie konwersji /Continuation Passing Style/ opisanej szczegółowo w sekcji [[ref:sec:cps-impl]]. Listing [[ref:code:ex-cps-errors]] demonstruje wykorzystanie wymienionych wyżej funkcji w generowanym w fazie konwersji CPS kodzie pośrednim.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie kontynuacji do implementacji obsługi błędów.}}
#+latex: \label{code:ex-cps-errors}
#+BEGIN_SRC scheme
;; Konwersja (raise error):
(let ((__handler (&uproc-error-handler)))
  (__handler __error
             (lambda (__value __ignored)
               (&set-uproc-error-handler! __handler)
               ...
               __value
               ...)))

;; Konwersja (handle expression new-handler):
(let ((__handler (&uproc-error-handler)))
  (&set-uproc-error-handler!
   (lambda (__error __restart)
     (&set-uproc-error-handler! __handler)
     ...
     __new-handler
     ...))
  ...
  __expression
  ...
  (&set-uproc-error-handler! __handler)
  ...)
#+end_src
#+latex: \end{listing}

Powyższy, kryptyczny przykład pokazuje relatywnie skomplikowany kod generowany dla fundamentalnie nieskomplikowanych operacji =raise= oraz =handle= realizujących obsługę błędów w języku =FOOF=. Należy zwrócić uwagę na zastosowanie kontynuacji - procedura obsługi sytuacji wyjątkowej jest zwykłą, reifikowaną do postaci funkcji kontynuacją, której zadaniem jest wywołanie faktycznej funkcji obsługującej zdarzenie. Sygnalizacja zaistnienia błędu polega wtedy na aplikacji tak zbudowanej kontynuacji z sygnalizowaną wartością oraz aktualną kontynuacją, która realizuje restart obliczeń.

Skomplikowanie powyższego kodu wynika z konieczności odpowiedniego zarządzania procedurami obsługi zdarzeń wyjątkowych - musi istnieć gwarancja, że zrestartowane obliczenia zostaną uruchomione z tą samą procedurą obsługi zdarzeń, a po ich zakończeniu zostanie przywrócona poprzednia procedura, natomiast nowodeklarowana procedura obsługi błędu powinna być uruchomiona w kontekście poprzednio zadeklarowanej procedury. Alternatywnym rozwiązaniem, które prowadzi do nieznacznego zredukowania skomplikowania powyższego kodu, jest rozszerzenie bazowego algorytmu konwersji przekazywania kontynuacji w taki sosób, by przekazywane były dwie kontynuacje - pierwsza, będąca włąściwą kontynuacją oraz druga, odpowiedzialna za obsługę sytuacji wyjątkowych [[cite:Appel1992]]. Implementacja tego rozwiązania nie jest dostatecznie opłacalna, powodując nieznaczny narzut szybkości i utrudniając implementację kilku kluczowych optymalizacji, w związku z czym nie została zrealizowana w implementacji języka =FOOF=.

** Implementacja procesów
Jednym z kluczowych elementów języka =FOOF= jest wsparcie dla przetwarzania współbieżnego zrealizowanego za pomocą notacji procesów. Procesy, zwane w nomenklaturze =FOOF= mikroprocesami (w celu rozróżnienia z relatywnie kosztownymi pod względem wykorzystania pamięci i szybkości przełączania procesami systemu operacyjnego) wymagają znacznego wsparcia ze strony środowiska uruchomieniowego języka.

Wsparcie to, w dodatku do uruchamiania procesów, przejawia się organizacją i zarządzaniem ich kontekstami. Kontekstem mikroprocesu jest zbiór globalnych wartości dostępnych i modyfikowanych podczas jego działania przez środowisko uruchomieniowe oraz różne funkcje wbudowane dostępne dla programistów. Schemat [[ref:fig:uproc-processes]] obrazuje organizację obiektu reprezentującego kontekst mikroprocesu.

#+begin_center
#+label: fig:uproc-processes
#+caption: Schemat kontekstu procesu obrazujący rejestry niezbędne do jego działania.
#+attr_latex: :width 0.6\textwidth :placement [H]
[[file:./img/uprocprocesses.pdf]]
#+end_center

Podstawowa wersja kontekstu mikroprocesu wymaga istnienia czterech rejestrów:
- pierwszy z nich, *header*, jednoznacznie identyfikuje obiekt jako kontekst mikroprocesu, dzięki czemu obiekty te mogą być przetwarzane przez programy języka =FOOF=.

- rejestr *status* określa aktualny stan, w którym znajduje się działający proces, jest to jedna z wartości: =running=, =waiting=, =halted= lub =waiting-4-message= oznaczające odpowiednio: działanie, oczekiwanie na uruchomienie, zatrzymanie lub oczekiwanie na wiadomość (opisane w sekcji [[ref:sec:actor-model-impl]]).

- rejest *cont* zawiera aktualnie uruchomianą kontynuacją w formacie trampoliny, czyli funkcję kodującą aktualną kontynuację oraz wartość, która zostanie do niej przekazana. Trampoliny tworzone są za pomocą wbudowanej funkcji =&yield-cont=.

- ostatni rejest, *handler*, reprezentuje aktualnie zadeklarowaną procedurę obsługi zdarzenia wyjątkowego, jest on modyfikowany za pośrednictwem wbudowanych funkcji =&uproc-error-handler= oraz =&set-uproc-error-handler!=.

Rejestry te są podstawowymi rejestrami niezbędnymi do organizacji działania mikroprocesów i są wykorzystywane przez wszystkie zaawansowane funkcjonalności języka. Opis kontekstu mikroprocesów będzie sukcesywnie rozwijany w następnych sekcjach wraz z opisem implementacji poszczególnych funkcjonalności.

** Harmonogramowanie procesów
#+LaTeX: \label{sec:cfs-impl}

#+begin_center
#+label: fig:uproc-cfs
#+caption: Dodatkowe rejestry kontekstu mikroprocesu wymagade do implementacji algorytmu /Completely Fair Scheduler/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uproccfs.pdf]]
#+end_center

- describe the Completely Fair Scheduler [cite:Pabla2009]
- add pseudocode listing showing the algorithm
- describe uProc context switching
- contrast current impl with previous one (lack of wait list - notifications, heaps instead of RBT, number of reductions instead of time) [cite:Sedgewick2008]
- contrast with erlang [cite:Armstrong1996]

** Implementacja Modelu Aktorowego
#+LaTeX: \label{sec:actor-model-impl}

- describe actor model briefly [cite:Hewitt1973] [cite:Clinger1981]

#+begin_center
#+label: fig:uproc-actor-model
#+caption: Dodatkowe rejestry kontekstu mikroprocesu wymagade do implementacji Modelu Aktorowego.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uprocactormodel.pdf]]
#+end_center

- describe modifications to the runtime required by actor model (*current-uproc*, uproc list, context fields)
- describe implementation of various actor model primitives

#+begin_center
#+label: fig:msg-send
#+caption: Diagram obrazujący efekty przekazywania wiadomości pomiędzy mikroprocesami.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/msgsend.pdf]]
#+end_center

- add some code examples and discussion of its effects and what happens
- contrast with erlang [cite:Armstrong1996]

** Dystrybucja obliczeń
- difference between concurrency & distribution
- describe modifications to the runtime in order to support distribution
- hint about using a simple protocol
- hint about moving this into stdlib

* Reprezentacja i przetwarzanie wiedzy
#+LaTeX: \label{sec:knowledge-engineering}

- describe how this needs a separate section
- elaborate on different ways of knowledge representation [cite:Wang2013] [cite:Barnaghi2012] [cite:Hachem2011] [cite:SomethingAboutProlog] [cite:SomethingAboutRBS]

** Reprezentacja wiedzy w języku
#+begin_center
#+label: fig:fact-rule-store
#+caption: Schemat działania wbudowanych baz faktów i reguł.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/factrulestore.pdf]]
#+end_center

- describe facts - signalling, assertion & retraction
- describe rules briefly - adding & disabling, triggering

** Algorytm Rete
- describe in detail the algorithm [cite:Forgy1982]

#+begin_center
#+label: fig:rete-network-merge
#+caption: Schemat łączenia podsieci w algorytmie /Rete/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/retemerge.pdf]]
#+end_center

- describe briefly its history [cite:Forgy1979]
- Rete vs naïve approach (vs CLIPS or similar ?)
- add a benchmark diagram showing how Rete is better
- contrast it with other algorithms [cite:Miranker1987]

** Implementacja Rete - wnioskowanie w przód
- describe what forward-chaining is
- describe naïve Rete - no network merging
- hint that this might be a good thing (future section)
- describe all the nodes [cite:Forgy1982]

** Implementacja wnioskowania wstecz
- describe what backward-chaining is
- describe fact store in detail - linear, in-memory database
- querying fact store = create a rule and apply all known facts to it

** Integracja z Systemem Uruchomieniowym
- describe how it sucks right now (notify-whenever instead of generic whenever, logic rule removal)
- describe possible integration with the module system (fact inference)
- describe possible representation of rules by autonomus processes [cite:Gupta1986]

#+begin_center
#+label: fig:distributed-rete
#+caption: Schemat działania rozproszonej wersji algorytmu /Rete/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/distributedrete.pdf]]
#+end_center

- hint at movig the implementation to the stdlib

* Podsumowanie
#+latex: \label{sec:outro}

- reiterate the goal of the thesis
- state how well has it been achieved

** Kompilator języka =FOOF=
- needs better optimizations
- needs better error handling

** Środowisko uruchomieniowe
- needs more stuff
- needs macroexpansion
- needs to drop RBS and move it into stdlib

** Przyszłe kierunki rozwoju
- more datatypes
- native compilation via LLVM
- bootstrapping compiler
- librarized RBS
- librarized distribution with data encryption & ACLs
- data-level paralellism

# The bibliography
#+begin_latex
\bibliographystyle{ieeetr}
\bibliography{bibs}
#+end_latex

#+latex: \appendix
* Gramatyka języka =FOOF=
#+LaTeX: \label{sec:foof-grammar}
- concrete language grammar in PEG or BNF

* Przykładowe programy
#+LaTeX: \label{sec:foof-examples}
Poniżej zaprezentowano przykładowe programy w języku =FOOF= i krótki opis ich działania. Programy mogą zostać skompilowane i uruchomione za pomocą udostępnionego interfejsu kompilatora i środowiska uruchomieniowego języka. W konsoli systemu należy w tym celu wywołać odpowiednio funkcje =compile= i =run= podając interesujący program jako parametr, na przykład:

#+BEGIN_EXAMPLE
> (compile 'program)
> (run 'program)
#+END_EXAMPLE

** Hello world!
Program definuje funkcję =hello= obrazującą podstawowe operacje języka i następnie wywołuje ją z jednym parametrem. Po uruchomieniu program powoduje wypisanie wiadomości =Hello world!= na ekranie komputera.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Popularny program \textit{Hello world!}.}}
#+latex: \label{code:ex-hello-world}
#+begin_src scheme
(define (hello world)
  (if (= nil world)
      (raise 'nope)
      (do (display "Hello ")
          (display world)
          (display "!")
          (newline))))

(hello "world")
#+end_src
#+latex: \end{listing}

** Funkcja Fibonacciego
Program prezentuje definicję funkcji Fibonacciego z wykorzystaniem konstrukcji =letrec=, służącej do definiowania funkcji rekursywnych. Następnie program oblicza wynik funkcji Fibonacciego dla liczby 23.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Definicja funkcji Fibonacciego.}}
#+latex: \label{code:ex-fibonacci}
#+begin_src scheme
(letrec ((fib (lambda (n)
                (if (< n 2)
                    n
                    (+ (fib (- n 1))
                       (fib (- n 2)))))))
  (fib 23))
#+end_src
#+latex: \end{listing}

** Obsługa błędów
Program prezentuje wykorzystanie wbudowanego w język systemu obsługi błędów. Deklarowana jest procedura obsługi błędów, która restartuje obliczenia z nową wartością. Następnie program dwukrotnie sygnalizuje wystąpienie błędu. Wynikiem działania programu jest liczba 24.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Zastosowanie wbudowanego mechanizmu obsługi błędów.}}
#+latex: \label{code:ex-error-handling}
#+begin_src scheme
(* 2 (handle (raise (raise 3))
             (lambda (e restart)
               (restart (* 2 e)))))
#+end_src
#+latex: \end{listing}

** Model Aktorowy
Program korzysta z dwóch komunikujących się procesów do zobrazowania sposobu wykorzystania zaimplementowanego w języku Modelu Aktorowego. Efektem działania programu jest wypisanie wiadomości =Hello world!= na ekranie komputera.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie prymitywnych operacji Modelu Aktorowego.}}
#+latex: \label{code:ex-actor-model}
#+begin_src scheme
(let ((pid (spawn (lambda ()
                    (let ((msg (recv)))
                      (display (cdr msg))
                      (newline)
                      (send (car msg) " world!"))))))
  (send pid (cons (self) "Hello"))
  (display (recv))
  (newline))
#+end_src
#+latex: \end{listing}

** Współbieżne obliczenia funkcji Fibonacciego
Program definiuje funkcję Fibonacciego oraz dodatkową funkcję wyświetlającą informacje o systemie. Następnie tworzone są trzy procesy współbieżnie obliczające wartość funkcji Fibonacciego dla liczby 30. Program periodycznie wyświetla różne informacje o działających procesach.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Równoległe obliczanie funkcji Fibonacciego.}}
#+latex: \label{code:ex-parallel-fibonacci}
#+begin_src scheme
(letrec ((fib (lambda (n)
                (if (< n 2)
                    n
                    (+ (fib (- n 1))
                       (fib (- n 2))))))
         (monitor (lambda ()
                    (task-info)
                    (sleep 2000)
                    (monitor))))
  (spawn (lambda ()
           (fib 30)))
  (spawn (lambda ()
           (fib 30)))
  (spawn (lambda ()
           (fib 30)))
  (monitor))
#+end_src
#+latex: \end{listing}

** System modułowy
Program definiuje dwa moduły - =logger= oraz =test=. Moduł =test= wymaga do działania implementacji modułu logowania. Program tworzy instancję modułu =logger= i następnie tworzy instancję modułu =test= wykorzystując uprzednio zdefiniowany moduł logowania. Efektem działania programu jest wypisanie dwóch wiadomości na ekranie komputera. Wiadomości są odpowiednio sformatowane przez moduł =logger=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wbudowanego systemu modułowego.}}
#+latex: \label{code:ex-module-system}
#+begin_src scheme
(module (logger)
  (define (log level string)
    (display "[")
    (display level)
    (display "] ")
    (display string)
    (newline))

  (define (debug string)
    (log 'DEBUG string))

  (define (info string)
    (log 'INFO string))

  (define (warn string)
    (log 'WARN string))

  (define (error string)
    (log 'ERROR string)))

(module (test logger)
  (define (do-something)
    (logger.info "doing something")
    (logger.error "failed badly!")))

(let ((t (test (logger))))
  (t.do-something))
#+end_src
#+latex: \end{listing}

** Wnioskowanie w przód
Program prezentuje wykorzystanie wbudowanego w język systemu regułowego. Definiowane są trzy funkcje, jedna z nich co pewien czas sygnalizuje zajście pewnego zdarzenia - upływ czasu. Druga funkcja oczekuje notyfikacji od systemu regułowego i wyświetla informacje o przechwyconych zdarzeniach. Trzecia funkcja, jest pomocniczą funkcją wyświetlającą informacje o procesach uruchomionych w systemie. Następnie program definiuje prostą regułę i uruchamia wszystkie niezbędne procesy.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wbudowanego systemu regułowego.}}
#+latex: \label{code:ex-forward-chaining}
#+begin_src scheme
(letrec ((monitor (lambda ()
                    (task-info)
                    (sleep 10000)
                    (monitor)))
         (timer (lambda (t)
                  (signal! `(curr-time ,t))
                  (sleep 1000)
                  (timer (+ t 1))))
         (listen (lambda ()
                   (let ((t (recv)))
                     (display "Current time: ")
                     (display (cdr (car t)))
                     (newline)
                     (listen)))))
  (spawn (lambda () (timer 0)))
  (notify-whenever (spawn (lambda ()
                            (listen)))
                   '(curr-time ?t))
  (monitor))
#+end_src
#+latex: \end{listing}

#+LaTeX: \pagebreak
** Obsługa złożonych zdarzeń
Program działa podobnie do przykładu z listingu [[ref:code:ex-forward-chaining]]. Definiowana jest złożona reguła, która notyfikuje proces nasłuchujący jedynie, gdy wartości powiązane z faktami =foo= oraz =bar= osiągają odpowiednie wartości.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Zastosowanie wbudowanego systemu regułowego do obsługi złożonych zdarzeń.}}
#+latex: \label{code:ex-complex-events}
#+begin_src scheme
(letrec ((monitor (lambda ()
                    (task-info)
                    (sleep 10000)
                    (monitor)))
         (notify (lambda (prefix t)
                   (assert! `(notify ,prefix ,(random)))
                   (sleep t)
                   (notify prefix t)))
         (listen (lambda ()
                   (let ((m (recv)))
                     (display "Complex event: ")
                     (display m)
                     (newline)
                     (listen)))))
  (notify-whenever (spawn listen)
                   '(filter (and (?notify foo ?foo)
                                 (?notify bar ?bar))
                            (>= ?foo 0.5)
                            (< ?foo 0.75)
                            (<= ?bar 0.1)))
  (spawn (lambda ()
           (notify 'foo 1000)))
  (spawn (lambda ()
           (notify 'bar 5000)))
  (monitor))
#+end_src
#+latex: \end{listing}

** Wnioskowanie wstecz
Program prezentuje wykorzystanie wnioskowania wstecz wbudowanego w język systemu regułowego. Na bazie faktów wykonywany jest szereg operacji, a następnie program odpytuje bazę faktów o wartości, dla których wystąpiły fakty =foo= oraz =bar=. Wynikiem działania programu jest asocjacja =(?value . 2)=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wnioskowania wstecz.}}
#+latex: \label{code:ex-backward-chaining}
#+begin_src scheme
(assert! '(foo 1))
(assert! '(foo 2))
(assert! '(foo 3))
(assert! '(bar 2))
(assert! '(bar 3))
(retract! '(foo 2))
(signal! '(foo 4))

(select '(and (foo ?value)
              (bar ?value)))
#+end_src
#+latex: \end{listing}

* Spis wbudowanych funkcji i makr języka =FOOF=
#+LaTeX: \label{sec:built-ins}

- list contents of bootstrap.scm
- describe what =&make-structure=, =&yield-cont= etc do
- list available macros

* Spisy rysunków i fragmentów kodu
#+latex: \label{sec:misc}

#+begin_latex
\begingroup
  \listoffigures
  \pagebreak
  \listofmylisting
\endgroup
#+end_latex
