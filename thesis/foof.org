# ###############################################################################
#+TITLE:
#+AUTHOR: Kajetan Rzepecki
#+DATE: 2015
#+LANGUAGE: pl
#
#+STARTUP: content
#+EXPORT_SELECT_TAGS: export
#+LaTeX_CLASS: aghdpl
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt]
#+LaTeX_HEADER: \usepackage[polish]{babel}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{multicol}
#+LATEX_HEADER: \usepackage[nottoc, notlof, notlot]{tocbibind}
#+OPTIONS: tags:nil, todo:nil, toc:nil
# ###################

# Helpers & Stuff
#+begin_src emacs-lisp :exports none
  (setq org-latex-minted-options
        '(("frame" "leftline") ("linenos" "true") ("mathescape" "true")))

  (setq org-export-latex-title-command "")
  (add-to-list 'org-latex-classes
               '("aghdpl"
                 "\\documentclass{aghdpl}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))

  (setq org-latex-classes (cdr org-latex-classes))
#+end_src

# AGH setup:
#+LATEX_HEADER: \shortauthor{K. Rzepecki}
#+LATEX_HEADER: \degreeprogramme{Informatyka}

#+LATEX_HEADER: \thesistype{Praca dyplomowa magisterska}

#+LATEX_HEADER: \titlePL{Projekt języka programowania wspierającego przetwarzanie rozproszone na platformach heterogenicznych.}
#+LATEX_HEADER: \titleEN{Design of a programming language with support for distributed computing on heterogenous platforms.}

#+LATEX_HEADER: \shorttitlePL{Projekt języka programowania wspierającego przetwarzanie rozproszone \dots}
#+LATEX_HEADER: \shorttitleEN{Design of a programming language with support for distributed computing \dots}

#+LATEX_HEADER: \supervisor{dr inż. Piotr Matyasik}

#+LATEX_HEADER: \department{Katedra Informatyki Stosowanej}

#+LATEX_HEADER: \faculty{Wydział Elektrotechniki, Automatyki,\protect\\[-1mm] Informatyki i Inżynierii Biomedycznej}

#+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję opiekunowi pracy za wsparcie merytoryczne oraz dobre rady edytorskie pomocne w tworzeniu pracy.}
# #+LATEX_HEADER: \acknowledgements{Serdecznie dziękuję Lucynie oraz siostrze Alicji za cierpliwość i wsparcie podczas tworzenia pracy dyplomowej.}

# Font stuff:
#+LATEX_HEADER: \setmainfont{Times New Roman}
#+LATEX_HEADER: \setmonofont{Consolas}

# Title pages & table of contents:
#+begin_latex
\titlepages
\tableofcontents
#+end_latex

# List of Listings specific:
#+begin_latex
\newcommand{\listlistingname}{\bfseries\Large{Spis listingów}}
\newlistof[chapter]{mylisting}{mlol}{\listlistingname}
\newcommand{\mylisting}[1]{%
  \refstepcounter{mylisting}%
  #1%
  \addcontentsline{mlol}{figure}
    {\protect\numberline{\thechapter.\thelisting}#1}\par%
}
\renewcommand{\cftbeforemloltitleskip}{20mm}
\renewcommand{\cftaftermloltitleskip}{5mm}
#+end_latex

* Wstęp
#+latex: \label{sec:intro}

Tematem pracy jest projekt i implementacja języka programowania wspierającego /przetwarzanie współbieżne/ i umożliwiającego tworzenie /systemów rozproszonych/ działających na /platformach heterogenicznych/.

Przetwarzanie współbieżne polega na podziale obliczeń na wiele procesów działających jednocześnie i konkurujących ze sobą o dostęp do ograniczonej ilości zasobów [[cite:McKenney2015]]. Procesy te mogą zostać rozproszone na wiele fizycznych maszyn, zachowując jednocześnie komunikację pomiędzy nimi, tworząc tym samym jeden koherentny system rozproszony [[cite:Tanenbaum2006]].

Projektowany język programowania powinien więc udostępniać przejrzystą i ogólną notację umożliwiającą definiowanie komunikujących się procesów, jednocześnie pozostając językiem ogólnego przeznaczenia. Dodatkowym wymogiem jest prostota przy zachowaniu ekspresywności - język ten powinien być zbudowany w oparciu o niewielką liczbę ortogonalnych, dobrze współgrających ze sobą mechanizmów, które pozwalają na implementację szerokiej gamy funkcjonalności [[cite:Backus1978]].

#+begin_center
#+label: fig:lang-parts
#+caption: Schemat interakcji poszczególnych elementów języka.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/langparts.pdf]]
#+end_center

W tym celu wymagane jest stworzenie kompilatora, czyli programu transformującego kod źródłowy języka programowania na format możliwy do uruchomienia w pewnym środowisku uruchomieniowym (ang. /runtime system/). Na środowisko takie zazwyczaj składa się zestaw podstawowych procedur wspólnych i niezbędnych do działania każdego programu. Schemat interakcji poszczególnych elementów projektu zaprezentowano na schemacie [[fig:lang-parts]].

Ostatnim wymogiem postawionym przed projektowanym językiem, jest wyjście naprzeciw licznym problemom występującym w systemach rozproszonych, w szczególności problemowi /heterogeniczności/, co umotywowano w następnej sekcji.

** Motywacja pracy
Tworzenie systemów rozproszonych jest zadaniem bardzo trudnym i wymaga wykorzystania specjalnie do tego przeznaczonych narzędzi - języków programowania, systemów bazodanowych i infrastruktury sieciowej. Na przestrzeni lat zidentyfikowano wiele kluczowych problemów manifestujących się we wszystkich systemach rozproszonych niezależnie od ich przeznaczenia. Tanenbaum oraz Van Steen w [[cite:Tanenbaum2006]] wymieniają następujące problemy:

- *dostępność* - systemy rozproszone działają zwykle na wielu odrębnych maszynach, istotnym jest więc zachowanie dostępu do wspólnych zasobów z każdej części systemu,

- *przezroczystość dystrybucji* - istotnym jest również ukrycie fizycznego rozproszenia procesów i zasobów, dzięki czemu system rozproszony z zewnątrz stanowi jedną, koherentną całość,

- *otwartość* - polega na standaryzacji komunikacji pomiędzy poszczególnymi częściami systemu, dzięki czemu możliwe jest dodawanie nowych elementów bez ingerencji w pozostałe,

- *skalowalność* - systemy rozproszone powinny umożliwiać płynną zmianę ilości zasobów, być dostępne dla użytkowników z wielu lokacji geograficznych oraz umożliwiać łatwe zarządzanie niezależnie od ich rozmiaru.

Warto zauważyć, iż /skalowalność/ jest przywoływana w folklorze programistycznym nieproporcjonalnie często, natomiast, istnieje wiele równie trudnych problemów, którym przeznacza się znacznie mniej uwagi, takich jak:

- *bezpieczeństwo systemu* - polega na kontroli dostępu do zasobów; w zależności od przeznaczenia systemu rozproszonego, jest najważniejszym aspektem jego budowy,

- *odporność na błędy* - polega na reagowaniu na zmiany (w szczególności wystąpienie błędów) zachodzące w systemie i podejmowaniu odpowiednich akcji w razie ich wystąpienia,

- *heterogeniczność* - polega na zróżnicowaniu platform sprzętowych wchodzących w skład fizycznej części systemu rozproszonego, a także poszczególnych logicznych części systemu.

Heterogeniczność jest problemem szczególnie trudnym, który powoli nabiera znaczenia wraz z pojawieniem się inicjatyw takich jak *Internet Rzeczy* (ang. /Internet of Things/) [[cite:Holler2014]], gdzie systemy rozproszone zbudowane są z dużej ilości bardzo zróżnicowanych maszyn. Maszyny te cechują się różną architekturą sprzętową, ilością zasobów, a także przeznaczeniem i funkcjonalnościami, które realizują i umożliwiają.

Na schemacie [[fig:hetero-iot]] przedstawiony został przykład heterogeniczności platformy sprzętowej w kontekście Internetu Rzeczy. Klient, korzystając z centralnego komputera, uzyskuje dostęp do danych sensorycznych pochodzących z szerokiej gamy różnych czujników i bazując na ich wartości jest w stanie zmieniać zachowanie równie zróżnicowanych efektorów. Całość odbywa się za pośrednictwem dedykowanych sterowników, ułatwiających skalowanie systemu.

#+begin_center
#+label: fig:hetero-iot
#+caption: Przykład systemu opartego o heterogeniczną platformę sprzętową.
#+attr_latex: :width 0.7\textwidth :placement [H]
[[file:./img/heteroiotexample.pdf]]
#+end_center

Każdy element takiego systemu, oznaczony na schemacie różnym kształtem oraz kolorem, reprezentuje maszynę udostępniającą różne zasoby i posiadającą różną fizyczną konstrukcję. Poszczególne elementy często działają w niekompatybilny sposób, w związku z czym wymagane jest wykorzystanie dedykowanych pośredników, których jedynym zadaniem jest /homogenizacja/ systemu.

Problem heterogeniczności dotyka również systemów rozproszonych, które działają na platformach homogenicznych, gdzie fizyczne maszyny są do siebie bardzo zbliżone, a często są komputerami ogólnego przeznaczenia. Przykład takiego systemu, zbudowanego w oparciu o zdobywającą popularność architekturę mikroserwisową [[cite:Richards2015]], został zawarty na schemacie [[fig:hetero-service]].

#+begin_center
#+label: fig:hetero-service
#+caption: Przykład systemu heterogenicznego niezależnie od platformy sprzętowej.
#+attr_latex: :width 0.7\textwidth :placement [H]
[[file:./img/heteroserviceexample.pdf]]
#+end_center

Użytkownik systemu łączy się z głównym serwisem, który następnie komunikuje się z innymi serwisami, realizującymi wymagane przezeń zadania. W celu poprawienia /odporności na błędy/ takiego systemu, w strategicznych miejscach umieszczono serwery zarządzające ruchem (ang. /load-balancer/), których zadaniem, analogicznie do przykładu ze schematu [[fig:hetero-iot]], jest /homogenizacja/ systemu.

W pierszym przypadku heterogeniczność wynika ze zróżnicowania maszyn należących do platformy sprzętowej, natomiast w drugim wynika ona z istnienia mikroserwisów, które realizują pojedyncze, konretnie sprecyzowane funkcjonalności. W obu przypadkach, heterogeniczność systemu prowadzi do powstania innych problemów, takich jak skalowalność i odporność na błędy, oraz konieczności wykorzystania dodatkowych elementów mających im zaradzić.

Często, sytuacja ta wynika z nieadekwatności narzędzi (w szczególności języków programowania) wykorzystanych do tworzenia systemu. Popularne języki programowania dążą do osiągnięcia *niezalożności od platformy* (ang. /platform independence/) stosując maszyny wirtualne i inne techniki mające na celu homogenizację platformy sprzętowej, kiedy w rzeczywistości osiągają *ignorancję platformy* nie umożliwiając refleksji na jej temat.

Jako alternatywę dla osiągnięcia niezależności od platformy, niniejsza praca wprowadza termin *świadomości platformy* (ang. /platform awareness/), czyli dążenia do udostępnienia wiedzy o strukturze budowanego systemu rozproszonego oraz platformy sprzętowej, na której działa, i umożliwienia refleksji na jej podstawie. Zaprezentowany w dalszej części pracy język programowania, roboczo zwany =FOOF= [fn:: Nazwa pochodzi od difluorku ditlenu, niezwykle reaktywnego, dysruptywnego i niebezpiecznego związku chemicznego, który nie ma zastosowania.], ma być uosobieniem ideologii świadomości platformy.

** Zawartość pracy
- list what is found where in the thesis

* Język =FOOF=
# Language ideology
- describe what was the driving force behind language design:
  - simplicity but not crudeness [cite:Backus1978]
  - orthogonal features [cite:Backus1978]
  - pragmatism [cite:Hoare1973]
  - platform awareness
- contrast with Scheme/Lisp & SML [cite:Sperber2010] [cite:Milner1997]
- hint at Spartan Programming (?)
- list contents of the chapter
- link to the full language grammar specification
- link to the sample programs

** Podstawowe typy danych
Listing [[code:data-types]] prezentuje proste typy danych dostępne w języku =FOOF=, są to podstawowe elementy budulcowe programów, które mają swoją reprezentację literałową.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Podstawowe typy danych dostępne w języku \texttt{FOOF}.}}
#+latex: \label{code:basic-data-types}
#+begin_src clojure
23.5
symbol
:symbol
"ciąg znaków"
(1 2 3)
[1 2 3]
{:a 1 :b 2}
#+end_src
#+latex: \end{listing}

- describe lists - pairs of atoms|lists [cite:McCarthy1960]
- describe numbers
- describe symbols
- describe strings
- describe vectors ?
- describe maps ?

** Funkcje
- a note about lambda calculus [cite:Church1932] [cite:Church1933]

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład implementacji wartości i operatorów logicznych jedynie za pomocą wyrażeń lambda.}}
#+latex: \label{code:ex-lambda-calculus}
#+BEGIN_SRC text
TRUE := λx.λy.x
FALSE := λx.λy.y

AND := λp.λq.p q p
OR := λp.λq.p p q
NOT := λp.λa.λb.p b a

AND TRUE FALSE
    ≡ (λp.λq.p q p) TRUE FALSE →β TRUE FALSE TRUE
    ≡ (λx.λy.x) FALSE TRUE →β FALSE
#+END_SRC
#+latex: \end{listing}

- describe closures

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ilustrujący działanie domknięć leksykalnych.}}
#+latex: \label{code:closures-at-work}
#+begin_src scheme
(let* ((x 23)
       (foo (lambda () x)))
  (let ((x 5))
    (display (foo)))) ;; Wyświetla liczbę 23
#+end_src
#+latex: \end{listing}

- mention funarg problem [cite:Abelson1996]
- mention recursion problem [cite:Felleisen1991] [cite:Goldberg2005] [cite:Rzepecki2015]

** Kontynuacje
- describe the notion of a continuation [cite:Reynolds1993]
- briefly describe CPS transformation and comment on code equivalence [cite:Appel1992]

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład konwersji \textit{Continuation Passing Style}.}}
#+latex: \label{code:ex-cps-principle}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Styl aplikatywny:
(+ 2 (* 3 4))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Styl Continuation Passing:
(*& 3 4
    (lambda (v)
      (+& 2 v identity)))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

- list some popular primitives - letcc, call/cc [cite:Sperber2010] [cite:Harper1998]
- hint at delimited control - shift & reset [cite:Dybvig2005]
- describe exceptions via continuations - handle & raise

** Przetwarzanie współbieżne i rozproszone
- briefly describe AMP vs SMP and contrast it with platform heterogeneity

#+begin_center
#+label: fig:homo-vs-hetero
#+caption: Podstawowe różnice pomiędzy platformami homogenicznymi oraz heterogenicznymi.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/homovshetero.pdf]]
#+end_center

#+begin_center
#+label: fig:amp-vs-smp
#+caption: Podstawowe różnice pomiędzy systemami asymetrycznymi i symetrycznymi.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/ampvssmp.pdf]]
#+end_center

- note that system doesn't need to run on a heterogenous platform to be heterogenous itself
- describe Actor Model [cite:Hewitt1973] [cite:Clinger1981]
- describe actor model primitives [cite:Hewitt1973]

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania prymitywnych operacji Modelu Aktorowego w języku.}}
#+latex: \label{code:ex-actor-model-usage}
#+begin_src scheme
(send (spawn (lambda ()
               (sleep 1000)
               (send (recv) 'message)))
      (self))

(equal? (recv) 'message)
#+end_src
#+latex: \end{listing}

- compare with Erlang [cite:Armstrong1996]
- hint at processes implemented via continuations (trampolines)
- comment on extending this framework to add distribution

** Reprezentacja wiedzy w języku
- describe use cases in the language
- describe various ways of knowledge representation [cite:Hachem2011] [cite:Samimi2014] [cite:Wang2013]
- describe primitive operations

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania prymitywnych operacji bazy wiedzy w języku.}}
#+latex: \label{code:ex-rbs-usage}
#+begin_src scheme
(signal! an-event)

(whenever set-of-conditions
  (lambda (_)
    (retract! some-fact)
    (assert! another-fact)))
#+end_src
#+latex: \end{listing}

- hint at using an RBS

** Makra
- describe macros & macroexpansion

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład działania systemu makr w języku \texttt{FOOF}.}}
#+latex: \label{code:ex-macroexpansion}
#+LaTeX: \begin{multicols}{2}
#+begin_src scheme
;; Przed makro-ekspansją:
(and 23 42)



(let ((x 23))
  (display x))


`(4 is ,(* 2 2))
#+end_src
#+LaTeX: \columnbreak
#+begin_src scheme
;; Po makro-ekspansji:
(if 23
    42
    false)

((lambda (x)
   (display x))
 23)

(list '4 'is (* 2 2))
#+end_src
#+LaTeX: \end{multicols}
#+latex: \end{listing}

- note about the usage of quasiquote [cite:Bawden1999]
- hint at problems of hygiene & add code example [cite:Queinnec1996]

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład ilustrujący problem higieniczności systemu makr w języku Scheme.}}
#+latex: \label{code:macro-hygiene}
#+begin_src scheme
(define-macro (unless c . b)
  `(if (not ,c)
       (begin ,@b)
       #void))

(let ((not identity))
  (unless #t
    (display "Hello world!")))
#+end_src
#+latex: \end{listing}

- compare different styles of macro systems (syntax-rules & define-macro) [cite:Sperber2010]
- note that macros are not first-class [cite:Bawden2000]
- contrast macros with other techniques (fexprs) [cite:Shutt2010]

** System modułowy
- describe the need for a module system [cite:Gasbichler2006]

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Przykład wykorzystania systemu modułowego języka \texttt{FOOF}.}}
#+latex: \label{code:ex-module-system-usage}
#+begin_src scheme
(module (A)
  (define (foo x)
    (+ 23 x)))

(module (B a)
  (define (bar)
    (a.foo 5)))

(let ((b (B (A))))
  (display (b.bar))) ;; Wyświetla liczbę 28
#+end_src
#+latex: \end{listing}

- describe structures - namespaces for definitions
- note about special structure access syntax - foo.bar
- describe modules - parameterized structures [cite:Rossberg2015]
- describe units - runnable modules
- describe protocols - a set of capabilities of a module (?)
- hint at protocols & SOA connection ?
- note about all these primitives being macros
- contrast described system with SML [cite:Milner1997]

- hint at problems of macros & modules coexisting [cite:Gasbichler2006]

* Kompilator języka =FOOF=
- mention technology selection & limitations (large project, little time) [cite:Ghuloum2006]
- mention possible bootstrapping
- briefly touch on the architecture [cite:Aho2006]
- hint at using Scheme for the boring details (datatypes etc)

** Architektura kompilatora
#+begin_center
#+label: fig:compilation-phases
#+caption: Schemat poszczególnych faz kompilacji i przykładowych danych będących wynikiem ich działania.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/compilationphases.pdf]]
#+end_center

- list compilation phases [cite:Aho2006] [cite:Ghuloum2006] [cite:Appel1992]
- list which phases have been actually implemented
- list which phases have been skipped and say why (optimization, code-gen, parsing)

** Parser
- briefly describe how Scheme praser works and what it produces [cite:Sperber2010] [cite:Abelson1996]
- hint at a possibility of replacing this with a PEG-based packrat [cite:Hutton1996] [cite:Ford2004]
- note about special quasiquote syntax [cite:Bawden1999]

** Makro-ekspansja
- describe macroexpantion phase
- describe why macroexpansion is hardcoded [cite:Gasbichler2006]
- list available macros
- show some examples of macro-expanded code

** Obsługa Systemu Modułowego
- describe how modules are handled right now [cite:Gasbichler2006] [cite:Rossberg2015]
- show some examples of macro-expanded structures & modules
- maby combine this with the previous section ?
- maby hint at special module access syntax (foo.bar.baz)

** Transformacja /Continuation Passing Style/
- describe what CPS is [cite:Appel1992] [cite:Kennedy2007]
- describe in detail how to transform simple stuff
- describe in detail how to transform functions (recursion problems & crude solution via mutation [cite:German1995], [cite:Kaser1993], [cite:Felleisen1991])
- describe in detail how to handle exceptions
- describe in detail why this is useful (partial evaluation, constant folding etc) [cite:Bacon2002]
- hint at emitting calls to primitive functions =&yield-cont=, =&uproc-error-handler= etc

** Generacja kodu
- describe how a subset of both Scheme and FOOF is emitted (contrast with Core Erlang) [cite:Carlsson2001] [cite:Carlsson2004]
- describe how Scheme is used for direct code execution
- hint at further development using LLVM [cite:SomethingAboutLLVM]
- mention a requirement to perform closure conversion or lambda lifting [cite:PeytonJones1992]
- add a code example contrasting closure conversion and lambda lifting

* Środowisko uruchomieniowe języka
- briefly touch on the architecture
- mention Scheme bootstrap

** Architektura środowiska uruchomieniowego
#+begin_center
#+label: fig:rt-architecture
#+caption: Schemat architektury środowiska uruchomieniowego języka =FOOF=.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/rtarchitecture.pdf]]
#+end_center

- describe various parts
- mention that this is single threaded and requires forking for real concurrency
- hint at in-depth description of RBS implementation in a future section

** Implementacja podstawowych typów danych
- describe scheme bootstrap [cite:Sperber2010]
- describe equivalence of various constructs such as lambdas

** Implementacja kontynuacji
- describe how continuations are handled without getting into CFS (returning cont + hole aka trampoline, contrast to how G-machine/TIM reductions work) [cite:Appel1992] [cite:PeytonJones1992]
- add a code example with step-by-step execution
- hint at debugging potential using step by step continuation execution with debug info inbetween

** Implementacja obsługi wyjątków
- describe how continuations are used for error handling - handle & raise
- note about restarts
- note about implementing letcc using handle & raise ?

** Implementacja procesów
- add a diagram of the uProc context - only include status, cont & handler registers
#+begin_center
#+label: fig:uproc-processes
#+caption: Schemat kontekstu procesu obrazujący rejestry niezbędne do jego działania.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uprocprocesses.pdf]]
#+end_center

- describe uProc context registers
- describe how trampolines play into this scheme (recall =&yield-cont=)
- contrast trampolines with corutines (more suitable in CPS) and yielding (done implicitly) [cite:Moura2009]
- describe how error handling is implemented (recall =&uproc-error-handler= etc)
- contrast with erlang [cite:Armstrong1996]

** Harmonogramowanie procesów
#+begin_center
#+label: fig:uproc-cfs
#+caption: Dodatkowe rejestry kontekstu mikroprocesu wymagade do implementacji algorytmu /Completely Fair Scheduler/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uproccfs.pdf]]
#+end_center

- describe the Completely Fair Scheduler [cite:Pabla2009]
- add pseudocode listing showing the algorithm
- describe uProc context switching
- contrast current impl with previous one (lack of wait list - notifications, heaps instead of RBT, number of reductions instead of time) [cite:Sedgewick2008]
- contrast with erlang [cite:Armstrong1996]

** Implementacja Modelu Aktorowego
- describe actor model briefly [cite:Hewitt1973] [cite:Clinger1981]

#+begin_center
#+label: fig:uproc-actor-model
#+caption: Dodatkowe rejestry kontekstu mikroprocesu wymagade do implementacji Modelu Aktorowego.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/uprocactormodel.pdf]]
#+end_center

- describe modifications to the runtime required by actor model (*current-uproc*, uproc list, context fields)
- describe implementation of various actor model primitives

#+begin_center
#+label: fig:msg-send
#+caption: Diagram obrazujący efekty przekazywania wiadomości pomiędzy mikroprocesami.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/msgsend.pdf]]
#+end_center

- add some code examples and discussion of its effects and what happens
- contrast with erlang [cite:Armstrong1996]

** Dystrybucja obliczeń
- difference between concurrency & distribution
- describe modifications to the runtime in order to support distribution
- hint about using a simple protocol
- hint about moving this into stdlib

* Reprezentacja i przetwarzanie wiedzy
- describe how this needs a separate section
- elaborate on different ways of knowledge representation [cite:Wang2013] [cite:Barnaghi2012] [cite:Hachem2011] [cite:SomethingAboutProlog] [cite:SomethingAboutRBS]

** Reprezentacja wiedzy w języku
#+begin_center
#+label: fig:fact-rule-store
#+caption: Schemat działania wbudowanych baz faktów i reguł.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/factrulestore.pdf]]
#+end_center

- describe facts - signalling, assertion & retraction
- describe rules briefly - adding & disabling, triggering

** Algorytm Rete
- describe in detail the algorithm [cite:Forgy1982]

#+begin_center
#+label: fig:rete-network-merge
#+caption: Schemat łączenia podsieci w algorytmie /Rete/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/retemerge.pdf]]
#+end_center

- describe briefly its history [cite:Forgy1979]
- Rete vs naïve approach (vs CLIPS or similar ?)
- add a benchmark diagram showing how Rete is better
- contrast it with other algorithms [cite:Miranker1987]

** Implementacja Rete - wnioskowanie w przód
- describe what forward-chaining is
- describe naïve Rete - no network merging
- hint that this might be a good thing (future section)
- describe all the nodes [cite:Forgy1982]

** Implementacja wnioskowania wstecz
- describe what backward-chaining is
- describe fact store in detail - linear, in-memory database
- querying fact store = create a rule and apply all known facts to it

** Integracja z Systemem Uruchomieniowym
- describe how it sucks right now (notify-whenever instead of generic whenever, logic rule removal)
- describe possible integration with the module system (fact inference)
- describe possible representation of rules by autonomus processes [cite:Gupta1986]

#+begin_center
#+label: fig:distributed-rete
#+caption: Schemat działania rozproszonej wersji algorytmu /Rete/.
#+attr_latex: :width 0.8\textwidth :placement [H]
[[file:./img/distributedrete.pdf]]
#+end_center

- hint at movig the implementation to the stdlib

* Podsumowanie
#+latex: \label{sec:outro}

- reiterate the goal of the thesis
- state how well has it been achieved

** Kompilator języka =FOOF=
- needs better optimizations
- needs better error handling

** Środowisko uruchomieniowe
- needs more stuff
- needs macroexpansion
- needs to drop RBS and move it into stdlib

** Przyszłe kierunki rozwoju
- more datatypes
- native compilation via LLVM
- bootstrapping compiler
- librarized RBS
- librarized distribution with data encryption & ACLs
- data-level paralellism

# The bibliography
#+begin_latex
\bibliographystyle{ieeetr}
\bibliography{bibs}
#+end_latex

#+latex: \appendix
* Gramatyka języka =FOOF=
- concrete language grammar in PEG or BNF

* Przykładowe programy
Poniżej zaprezentowano przykładowe programy w języku =FOOF= i krótki opis ich działania. Programy mogą zostać skompilowane i uruchomione za pomocą udostępnionego interfejsu kompilatora i środowiska uruchomieniowego języka. W konsoli systemu należy w tym celu wywołać odpowiednio funkcje =compile= i =run= podając interesujący program jako parametr, na przykład:

#+BEGIN_EXAMPLE
> (compile 'program)
> (run 'program)
#+END_EXAMPLE

** Hello world!
Program definuje funkcję =hello= obrazującą podstawowe operacje języka i następnie wywołuje ją z jednym parametrem. Po uruchomieniu program powoduje wypisanie wiadomości =Hello world!= na ekranie komputera.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Popularny program \textit{Hello world!}.}}
#+latex: \label{code:ex-hello-world}
#+begin_src scheme
(define (hello world)
  (if (= nil world)
      (raise 'nope)
      (do (display "Hello ")
          (display world)
          (display "!")
          (newline))))

(hello "world")
#+end_src
#+latex: \end{listing}


#+LaTeX: \pagebreak
** Funkcja Fibonacciego
Program prezentuje definicję funkcji Fibonacciego z wykorzystaniem konstrukcji =letrec=, służącej do definiowania funkcji rekursywnych. Następnie program oblicza wynik funkcji Fibonacciego dla liczby 23.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Definicja funkcji Fibonacciego.}}
#+latex: \label{code:ex-fibonacci}
#+begin_src scheme
(letrec ((fib (lambda (n)
                (if (< n 2)
                    n
                    (+ (fib (- n 1))
                       (fib (- n 2)))))))
  (fib 23))
#+end_src
#+latex: \end{listing}

** Współbieżne obliczenia funkcji Fibonacciego
Program definiuje funkcję Fibonacciego oraz dodatkową funkcję wyświetlającą informacje o systemie. Następnie tworzone są trzy procesy współbieżnie obliczające wartość funkcji Fibonacciego dla liczby 30. Program periodycznie wyświetla różne informacje o działających procesach.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Równoległe obliczanie funkcji Fibonacciego.}}
#+latex: \label{code:ex-parallel-fibonacci}
#+begin_src scheme
(letrec ((fib (lambda (n)
                (if (< n 2)
                    n
                    (+ (fib (- n 1))
                       (fib (- n 2))))))
         (monitor (lambda ()
                    (task-info)
                    (sleep 2000)
                    (monitor))))
  (spawn (lambda ()
           (fib 30)))
  (spawn (lambda ()
           (fib 30)))
  (spawn (lambda ()
           (fib 30)))
  (monitor))
#+end_src
#+latex: \end{listing}

** Obsługa błędów
Program prezentuje wykorzystanie wbudowanego w język systemu obsługi błędów. Deklarowana jest procedura obsługi błędów, która restartuje obliczenia z nową wartością. Następnie program dwukrotnie sygnalizuje wystąpienie błędu. Wynikiem działania programu jest liczba 24.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Zastosowanie wbudowanego mechanizmu obsługi błędów.}}
#+latex: \label{code:ex-error-handling}
#+begin_src scheme
(* 2 (handle (raise (raise 3))
             (lambda (e restart)
               (restart (* 2 e)))))
#+end_src
#+latex: \end{listing}

** Model Aktorowy
Program korzysta z dwóch komunikujących się procesów do zobrazowania sposobu wykorzystania zaimplementowanego w języku Modelu Aktorowego. Efektem działania programu jest wypisanie wiadomości =Hello world!= na ekranie komputera.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie prymitywnych operacji Modelu Aktorowego.}}
#+latex: \label{code:ex-actor-model}
#+begin_src scheme
(let ((pid (spawn (lambda ()
                    (let ((msg (recv)))
                      (display (cdr msg))
                      (newline)
                      (send (car msg) " world!"))))))
  (send pid (cons (self) "Hello"))
  (display (recv))
  (newline))
#+end_src
#+latex: \end{listing}


#+LaTeX: \pagebreak
** System modułowy
Program definiuje dwa moduły - =logger= oraz =test=. Moduł =test= wymaga do działania implementacji modułu logowania. Program tworzy instancję modułu =logger= i następnie tworzy instancję modułu =test= wykorzystując uprzednio zdefiniowany moduł logowania. Efektem działania programu jest wypisanie dwóch wiadomości na ekranie komputera. Wiadomości są odpowiednio sformatowane przez moduł =logger=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wbudowanego systemu modułowego.}}
#+latex: \label{code:ex-module-system}
#+begin_src scheme
(module (logger)
  (define (log level string)
    (display "[")
    (display level)
    (display "] ")
    (display string)
    (newline))

  (define (debug string)
    (log 'DEBUG string))

  (define (info string)
    (log 'INFO string))

  (define (warn string)
    (log 'WARN string))

  (define (error string)
    (log 'ERROR string)))

(module (test logger)
  (define (do-something)
    (logger.info "doing something")
    (logger.error "failed badly!")))

(let ((t (test (logger))))
  (t.do-something))
#+end_src
#+latex: \end{listing}

** Wnioskowanie w przód
Program prezentuje wykorzystanie wbudowanego w język systemu regułowego. Definiowane są trzy funkcje, jedna z nich co pewien czas sygnalizuje zajście pewnego zdarzenia - upływ czasu. Druga funkcja oczekuje notyfikacji od systemu regułowego i wyświetla informacje o przechwyconych zdarzeniach. Trzecia funkcja, jest pomocniczą funkcją wyświetlającą informacje o procesach uruchomionych w systemie. Następnie program definiuje prostą regułę i uruchamia wszystkie niezbędne procesy.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wbudowanego systemu regułowego.}}
#+latex: \label{code:ex-forward-chaining}
#+begin_src scheme
(letrec ((monitor (lambda ()
                    (task-info)
                    (sleep 10000)
                    (monitor)))
         (timer (lambda (t)
                  (signal! `(curr-time ,t))
                  (sleep 1000)
                  (timer (+ t 1))))
         (listen (lambda ()
                   (let ((t (recv)))
                     (display "Current time: ")
                     (display (cdr (car t)))
                     (newline)
                     (listen)))))
  (spawn (lambda () (timer 0)))
  (notify-whenever (spawn (lambda ()
                            (listen)))
                   '(curr-time ?t))
  (monitor))
#+end_src
#+latex: \end{listing}


#+LaTeX: \pagebreak
** Obsługa złożonych zdarzeń
Program działa podobnie do przykładu z listingu [[code:ex-forward-chaining]]. Definiowana jest złożona reguła, która notyfikuje proces nasłuchujący jedynie, gdy wartości powiązane z faktami =foo= oraz =bar= osiągają odpowiednie wartości.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Zastosowanie wbudowanego systemu regułowego do obsługi złożonych zdarzeń.}}
#+latex: \label{code:ex-complex-events}
#+begin_src scheme
(letrec ((monitor (lambda ()
                    (task-info)
                    (sleep 10000)
                    (monitor)))
         (notify (lambda (prefix t)
                   (assert! `(notify ,prefix ,(random)))
                   (sleep t)
                   (notify prefix t)))
         (listen (lambda ()
                   (let ((m (recv)))
                     (display "Complex event: ")
                     (display m)
                     (newline)
                     (listen)))))
  (notify-whenever (spawn listen)
                   '(filter (and (?notify foo ?foo)
                                 (?notify bar ?bar))
                            (>= ?foo 0.5)
                            (< ?foo 0.75)
                            (<= ?bar 0.1)))
  (spawn (lambda ()
           (notify 'foo 1000)))
  (spawn (lambda ()
           (notify 'bar 5000)))
  (monitor))
#+end_src
#+latex: \end{listing}


#+LaTeX: \pagebreak
** Wnioskowanie wstecz
Program prezentuje wykorzystanie wnioskowania wstecz wbudowanego w język systemu regułowego. Na bazie faktów wykonywany jest szereg operacji, a następnie program odpytuje bazę faktów o wartości, dla których wystąpiły fakty =foo= oraz =bar=. Wynikiem działania programu jest asocjacja =(?value . 2)=.

#+latex: \begin{listing}[H]
#+latex: \caption{\mylisting{Wykorzystanie wnioskowania wstecz.}}
#+latex: \label{code:ex-backward-chaining}
#+begin_src scheme
(assert! '(foo 1))
(assert! '(foo 2))
(assert! '(foo 3))
(assert! '(bar 2))
(assert! '(bar 3))
(retract! '(foo 2))
(signal! '(foo 4))

(select '(and (foo ?value)
              (bar ?value)))
#+end_src
#+latex: \end{listing}

* Spis wbudowanych funkcji języka =FOOF=
- list contents of bootstrap.scm
- describe what =&make-structure=, =&yield-cont= etc do

* Spisy rysunków i fragmentów kodu
#+latex: \label{sec:misc}

#+begin_latex
\begingroup
  \listoffigures
  \pagebreak
  \listofmylisting
\endgroup
#+end_latex
